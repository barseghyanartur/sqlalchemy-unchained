
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="lang:clipboard.copy" content="Copy to clipboard">
  <meta name="lang:clipboard.copied" content="Copied to clipboard">
  <meta name="lang:search.language" content="en">
  <meta name="lang:search.pipeline.stopwords" content="True">
  <meta name="lang:search.pipeline.trimmer" content="True">
  <meta name="lang:search.result.none" content="No matching documents">
  <meta name="lang:search.result.one" content="1 matching document">
  <meta name="lang:search.result.other" content="# matching documents">
  <meta name="lang:search.tokenizer" content="[\s\-]+">

  
    <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin="">
    <link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono:400,500,700&display=fallback">

    <style>
      body,
      input {
        font-family: "Roboto", "Helvetica Neue", Helvetica, Arial, sans-serif
      }

      code,
      kbd,
      pre {
        font-family: "Roboto Mono", "Courier New", Courier, monospace
      }
    </style>
  

  <link rel="stylesheet" href="../../../_static/stylesheets/application.css"/>
  <link rel="stylesheet" href="../../../_static/stylesheets/application-palette.css"/>
  <link rel="stylesheet" href="../../../_static/stylesheets/application-fixes.css"/>
  
  <link rel="stylesheet" href="../../../_static/fonts/material-icons.css"/>
  
  <meta name="theme-color" content="#3f51b5">
  <script src="../../../_static/javascripts/modernizr.js"></script>
  
  
  
    <title>sqlalchemy.orm.query &#8212; SQLAlchemy Unchained v0.9.1 documentation</title>
    <link rel="stylesheet" href="../../../_static/material.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  
   
  
  <script src="../../../_static/javascripts/version_dropdown.js"></script>
  <script>
    var json_loc = "../../../"versions.json"",
        target_loc = "../../../../",
        text = "Versions";
    $( document ).ready( add_version_dropdown(json_loc, target_loc, text));
  </script>


  </head>
  <body dir=ltr
        data-md-color-primary=blue data-md-color-accent=light-blue>
  
  <svg class="md-svg">
    <defs data-children-count="0">
      
      <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
      
    </defs>
  </svg>
  
  <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer">
  <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search">
  <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
  <a href="#_modules/sqlalchemy/orm/query" tabindex="1" class="md-skip"> Skip to content </a>
  <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex navheader">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="/" title="SQLAlchemy Unchained v0.9.1 documentation" class="md-header-nav__button md-logo">
          
            <i class="md-icon">&#8734</i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          <span class="md-header-nav__topic">
            <a href="/" title="SQLAlchemy Unchained v0.9.1 documentation">SQLAlchemy Unchained</a>
          </span>
          <span class="md-header-nav__topic">
            <a href="" title="sqlalchemy.orm.query">
              sqlalchemy.orm.query
            </a>
          </span>
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
        
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" action="../../../search.html" method="GET" name="search">
      <input type="text" class="md-search__input" name="q" placeholder="Search"
             autocapitalize="off" autocomplete="off" spellcheck="false"
             data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>

      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            <a href="https://github.com/briancappello/sqlalchemy-unchained" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    SQLAlchemy Unchained
  </div>
</a>
          </div>
        </div>
      
    </div>
  </nav>
</header>

  
  <div class="md-container">
    
  
  <div class="md-hero"
       data-md-component="hero"
  >
    <div class="md-hero__inner md-grid">
      <p>Enhanced declarative models for SQLAlchemy</p>
    </div>
  </div>

    
    
  <nav class="md-tabs" data-md-component="tabs">
    <div class="md-tabs__inner md-grid">
      <ul class="md-tabs__list">
          <li class="md-tabs__item"><a href="../../index.html" class="md-tabs__link">Module code</a></li>
      </ul>
    </div>
  </nav>
    <main class="md-main">
      <div class="md-main__inner md-grid" data-md-component="container">
        
          <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../../../table-of-contents.html" title="SQLAlchemy Unchained v0.9.1 documentation" class="md-nav__button md-logo">
      
        <i class="md-icon">&#8734</i>
      
    </a>
    <a href="../../../table-of-contents.html"
       title="SQLAlchemy Unchained v0.9.1 documentation">SQLAlchemy Unchained</a>
  </label>
    <div class="md-nav__source">
      <a href="https://github.com/briancappello/sqlalchemy-unchained" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    SQLAlchemy Unchained
  </div>
</a>
    </div>
  
  


  

  

  <ul class="md-nav__list">
    <li class="md-nav__item">
      

      <a href="../../../index.html"
         class="md-nav__link"
      >
        Introducing SQLAlchemy Unchained
      </a>

      
    </li>
    <li class="md-nav__item">
      

      <a href="../../../api.html"
         class="md-nav__link"
      >
        API Documentation
      </a>

      
    </li>
  </ul>
  

</nav>
              </div>
            </div>
          </div>
          <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                

<nav class="md-nav md-nav--secondary">
  <ul class="md-nav__list" data-md-scrollfix="">
      

<li id="searchbox" class="md-nav__item"></li>

  </ul>
</nav>
              </div>
            </div>
          </div>
        
        <div class="md-content">
          <article class="md-content__inner md-typeset" role="main">
            
  <h1 id="modules-sqlalchemy-orm-query--page-root">Source code for sqlalchemy.orm.query</h1><div class="highlight"><pre>
<span></span><span class="c1"># orm/query.py</span>
<span class="c1"># Copyright (C) 2005-2019 the SQLAlchemy authors and contributors</span>
<span class="c1"># &lt;see AUTHORS file&gt;</span>
<span class="c1">#</span>
<span class="c1"># This module is part of SQLAlchemy and is released under</span>
<span class="c1"># the MIT License: http://www.opensource.org/licenses/mit-license.php</span>

<span class="sd">"""The Query class and support.</span>

<span class="sd">Defines the :class:`.Query` class, the central</span>
<span class="sd">construct used by the ORM to construct database queries.</span>

<span class="sd">The :class:`.Query` class should not be confused with the</span>
<span class="sd">:class:`.Select` class, which defines database</span>
<span class="sd">SELECT operations at the SQL (non-ORM) level.  ``Query`` differs from</span>
<span class="sd">``Select`` in that it returns ORM-mapped objects and interacts with an</span>
<span class="sd">ORM session, whereas the ``Select`` construct interacts directly with the</span>
<span class="sd">database to return iterable result sets.</span>

<span class="sd">"""</span>

<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">chain</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">attributes</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">exc</span> <span class="k">as</span> <span class="n">orm_exc</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">interfaces</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">loading</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">persistence</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">properties</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="k">import</span> <span class="n">_entity_descriptor</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="k">import</span> <span class="n">_generative</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="k">import</span> <span class="n">_is_aliased_class</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="k">import</span> <span class="n">_is_mapped_class</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="k">import</span> <span class="n">_orm_columns</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="k">import</span> <span class="n">InspectionAttr</span>
<span class="kn">from</span> <span class="nn">.path_registry</span> <span class="k">import</span> <span class="n">PathRegistry</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="k">import</span> <span class="n">_entity_corresponds_to</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="k">import</span> <span class="n">aliased</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="k">import</span> <span class="n">AliasedClass</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="k">import</span> <span class="n">join</span> <span class="k">as</span> <span class="n">orm_join</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="k">import</span> <span class="n">object_mapper</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="k">import</span> <span class="n">ORMAdapter</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="k">import</span> <span class="n">with_parent</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">exc</span> <span class="k">as</span> <span class="n">sa_exc</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">inspect</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">inspection</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">log</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">sql</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">..sql</span> <span class="k">import</span> <span class="n">expression</span>
<span class="kn">from</span> <span class="nn">..sql</span> <span class="k">import</span> <span class="n">util</span> <span class="k">as</span> <span class="n">sql_util</span>
<span class="kn">from</span> <span class="nn">..sql</span> <span class="k">import</span> <span class="n">visitors</span>
<span class="kn">from</span> <span class="nn">..sql.base</span> <span class="k">import</span> <span class="n">ColumnCollection</span>
<span class="kn">from</span> <span class="nn">..sql.expression</span> <span class="k">import</span> <span class="n">_interpret_as_from</span>
<span class="kn">from</span> <span class="nn">..sql.selectable</span> <span class="k">import</span> <span class="n">ForUpdateArg</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"Query"</span><span class="p">,</span> <span class="s2">"QueryContext"</span><span class="p">,</span> <span class="s2">"aliased"</span><span class="p">]</span>


<span class="n">_path_registry</span> <span class="o">=</span> <span class="n">PathRegistry</span><span class="o">.</span><span class="n">root</span>


<span class="nd">@inspection</span><span class="o">.</span><span class="n">_self_inspects</span>
<span class="nd">@log</span><span class="o">.</span><span class="n">class_logger</span>
<span class="k">class</span> <span class="nc">Query</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">"""ORM-level SQL construction object.</span>

<span class="sd">    :class:`.Query` is the source of all SELECT statements generated by the</span>
<span class="sd">    ORM, both those formulated by end-user query operations as well as by</span>
<span class="sd">    high level internal operations such as related collection loading.  It</span>
<span class="sd">    features a generative interface whereby successive calls return a new</span>
<span class="sd">    :class:`.Query` object, a copy of the former with additional</span>
<span class="sd">    criteria and options associated with it.</span>

<span class="sd">    :class:`.Query` objects are normally initially generated using the</span>
<span class="sd">    :meth:`~.Session.query` method of :class:`.Session`, and in</span>
<span class="sd">    less common cases by instantiating the :class:`.Query` directly and</span>
<span class="sd">    associating with a :class:`.Session` using the :meth:`.Query.with_session`</span>
<span class="sd">    method.</span>

<span class="sd">    For a full walkthrough of :class:`.Query` usage, see the</span>
<span class="sd">    :ref:`ormtutorial_toplevel`.</span>

<span class="sd">    """</span>

    <span class="n">_only_return_tuples</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_enable_eagerloads</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_enable_assertions</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_with_labels</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_criterion</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_yield_per</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_order_by</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_group_by</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_having</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_distinct</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_prefixes</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_suffixes</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_offset</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_limit</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_for_update_arg</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_statement</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_correlate</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">()</span>
    <span class="n">_populate_existing</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_invoke_all_eagers</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_version_check</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_autoflush</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_only_load_props</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_refresh_state</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_refresh_identity_token</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_from_obj</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">_join_entities</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">_select_from_entity</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_mapper_adapter_map</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">_filter_aliases</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">_from_obj_alias</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_joinpath</span> <span class="o">=</span> <span class="n">_joinpoint</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">immutabledict</span><span class="p">()</span>
    <span class="n">_execution_options</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">immutabledict</span><span class="p">()</span>
    <span class="n">_params</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">immutabledict</span><span class="p">()</span>
    <span class="n">_attributes</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">immutabledict</span><span class="p">()</span>
    <span class="n">_with_options</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">_with_hints</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">_enable_single_crit</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_orm_only_adapt</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_orm_only_from_obj_alias</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_current_path</span> <span class="o">=</span> <span class="n">_path_registry</span>
    <span class="n">_has_mapper_entities</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_bake_ok</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">lazy_loaded_from</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">"""An :class:`.InstanceState` that is using this :class:`.Query` for a</span>
<span class="sd">    lazy load operation.</span>

<span class="sd">    This can be used for extensions like the horizontal sharding extension</span>
<span class="sd">    as well as event handlers and custom mapper options to determine</span>
<span class="sd">    when a query is being used to lazy load a relationship on an object.</span>

<span class="sd">    .. versionadded:: 1.2.9</span>

<span class="sd">    """</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entities</span><span class="p">,</span> <span class="n">session</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""Construct a :class:`.Query` directly.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            q = Query([User, Address], session=some_session)</span>

<span class="sd">        The above is equivalent to::</span>

<span class="sd">            q = some_session.query(User, Address)</span>

<span class="sd">        :param entities: a sequence of entities and/or SQL expressions.</span>

<span class="sd">        :param session: a :class:`.Session` with which the :class:`.Query`</span>
<span class="sd">         will be associated.   Optional; a :class:`.Query` can be associated</span>
<span class="sd">         with a :class:`.Session` generatively via the</span>
<span class="sd">         :meth:`.Query.with_session` method as well.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Session.query`</span>

<span class="sd">            :meth:`.Query.with_session`</span>

<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="n">session</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_polymorphic_adapters</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_entities</span><span class="p">(</span><span class="n">entities</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_entities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entities</span><span class="p">,</span> <span class="n">entity_wrapper</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">entity_wrapper</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">entity_wrapper</span> <span class="o">=</span> <span class="n">_QueryEntity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_primary_entity</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_mapper_entities</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># 1. don't run util.to_list() or _set_entity_selectables</span>
        <span class="c1">#    if no entities were passed - major performance bottleneck</span>
        <span class="c1">#    from lazy loader implementation when it seeks to use Query</span>
        <span class="c1">#    class for an identity lookup, causes test_orm.py to fail</span>
        <span class="c1">#    with thousands of extra function calls, see issue #4228</span>
        <span class="c1">#    for why this use had to be added</span>
        <span class="c1"># 2. can't use classmethod on Query because session.query_cls</span>
        <span class="c1">#    is an arbitrary callable in some user recipes, not</span>
        <span class="c1">#    necessarily a class, so we don't have the class available.</span>
        <span class="c1">#    see issue #4256</span>
        <span class="c1"># 3. can't do "if entities is not None" because we usually get here</span>
        <span class="c1">#    from session.query() which takes in *entities.</span>
        <span class="c1"># 4. can't do "if entities" because users make use of undocumented</span>
        <span class="c1">#    to_list() behavior here and they pass clause expressions that</span>
        <span class="c1">#    can't be evaluated as boolean.  See issue #4269.</span>
        <span class="k">if</span> <span class="n">entities</span> <span class="o">!=</span> <span class="p">():</span>
            <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">util</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">entities</span><span class="p">):</span>
                <span class="n">entity_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ent</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_set_entity_selectables</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_entity_selectables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entities</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mapper_adapter_map</span> <span class="o">=</span> <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mapper_adapter_map</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">entities</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">entity</span> <span class="ow">in</span> <span class="n">ent</span><span class="o">.</span><span class="n">entities</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">entity</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                    <span class="n">ext_info</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">entity</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="ow">not</span> <span class="n">ext_info</span><span class="o">.</span><span class="n">is_aliased_class</span>
                        <span class="ow">and</span> <span class="n">ext_info</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">with_polymorphic</span>
                    <span class="p">):</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">ext_info</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">persist_selectable</span>
                            <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polymorphic_adapters</span>
                        <span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_mapper_loads_polymorphically_with</span><span class="p">(</span>
                                <span class="n">ext_info</span><span class="o">.</span><span class="n">mapper</span><span class="p">,</span>
                                <span class="n">sql_util</span><span class="o">.</span><span class="n">ColumnAdapter</span><span class="p">(</span>
                                    <span class="n">ext_info</span><span class="o">.</span><span class="n">selectable</span><span class="p">,</span>
                                    <span class="n">ext_info</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">_equivalent_columns</span><span class="p">,</span>
                                <span class="p">),</span>
                            <span class="p">)</span>
                        <span class="n">aliased_adapter</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">elif</span> <span class="n">ext_info</span><span class="o">.</span><span class="n">is_aliased_class</span><span class="p">:</span>
                        <span class="n">aliased_adapter</span> <span class="o">=</span> <span class="n">ext_info</span><span class="o">.</span><span class="n">_adapter</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">aliased_adapter</span> <span class="o">=</span> <span class="kc">None</span>

                    <span class="n">d</span><span class="p">[</span><span class="n">entity</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ext_info</span><span class="p">,</span> <span class="n">aliased_adapter</span><span class="p">)</span>
                <span class="n">ent</span><span class="o">.</span><span class="n">setup_entity</span><span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="p">[</span><span class="n">entity</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_mapper_loads_polymorphically_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="p">,</span> <span class="n">adapter</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">m2</span> <span class="ow">in</span> <span class="n">mapper</span><span class="o">.</span><span class="n">_with_polymorphic_mappers</span> <span class="ow">or</span> <span class="p">[</span><span class="n">mapper</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_polymorphic_adapters</span><span class="p">[</span><span class="n">m2</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapter</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">m2</span><span class="o">.</span><span class="n">iterate_to_root</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_polymorphic_adapters</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">local_table</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapter</span>

    <span class="k">def</span> <span class="nf">_set_select_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">set_base_alias</span><span class="p">):</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">select_from_alias</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">from_obj</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">:</span>
            <span class="n">info</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">from_obj</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s2">"mapper"</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">info</span><span class="o">.</span><span class="n">is_mapper</span> <span class="ow">or</span> <span class="n">info</span><span class="o">.</span><span class="n">is_aliased_class</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_select_from_entity</span> <span class="o">=</span> <span class="n">info</span>
                <span class="k">if</span> <span class="n">set_base_alias</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">info</span><span class="o">.</span><span class="n">is_aliased_class</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                        <span class="s2">"A selectable (FromClause) instance is "</span>
                        <span class="s2">"expected when the base alias is being set."</span>
                    <span class="p">)</span>
                <span class="n">fa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">selectable</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">info</span><span class="o">.</span><span class="n">is_selectable</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                    <span class="s2">"argument is not a mapped class, mapper, "</span>
                    <span class="s2">"aliased(), or FromClause instance."</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">from_obj</span><span class="p">,</span> <span class="n">expression</span><span class="o">.</span><span class="n">SelectBase</span><span class="p">):</span>
                    <span class="n">from_obj</span> <span class="o">=</span> <span class="n">from_obj</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">set_base_alias</span><span class="p">:</span>
                    <span class="n">select_from_alias</span> <span class="o">=</span> <span class="n">from_obj</span>
                <span class="n">fa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">from_obj</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">fa</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">set_base_alias</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">select_from_alias</span><span class="p">,</span> <span class="n">expression</span><span class="o">.</span><span class="n">Alias</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">equivs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__all_equivs</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj_alias</span> <span class="o">=</span> <span class="n">sql_util</span><span class="o">.</span><span class="n">ColumnAdapter</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">equivs</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="n">set_base_alias</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s2">"mapper"</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">info</span><span class="o">.</span><span class="n">is_aliased_class</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj_alias</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">_adapter</span>

    <span class="k">def</span> <span class="nf">_reset_polymorphic_adapter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">m2</span> <span class="ow">in</span> <span class="n">mapper</span><span class="o">.</span><span class="n">_with_polymorphic_mappers</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_polymorphic_adapters</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">m2</span><span class="o">.</span><span class="n">iterate_to_root</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_polymorphic_adapters</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">local_table</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_adapt_polymorphic_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">"parententity"</span> <span class="ow">in</span> <span class="n">element</span><span class="o">.</span><span class="n">_annotations</span><span class="p">:</span>
            <span class="n">search</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">_annotations</span><span class="p">[</span><span class="s2">"parententity"</span><span class="p">]</span>
            <span class="n">alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polymorphic_adapters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">search</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">alias</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">alias</span><span class="o">.</span><span class="n">adapt_clause</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">expression</span><span class="o">.</span><span class="n">FromClause</span><span class="p">):</span>
            <span class="n">search</span> <span class="o">=</span> <span class="n">element</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s2">"table"</span><span class="p">):</span>
            <span class="n">search</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">table</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polymorphic_adapters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">search</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">alias</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">alias</span><span class="o">.</span><span class="n">adapt_clause</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_adapt_col_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cols</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_clause</span><span class="p">(</span>
                <span class="n">expression</span><span class="o">.</span><span class="n">_literal_as_label_reference</span><span class="p">(</span><span class="n">o</span><span class="p">),</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">cols</span>
        <span class="p">]</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">_set_lazyload_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lazy_loaded_from</span> <span class="o">=</span> <span class="n">state</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">_adapt_all_clauses</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orm_only_adapt</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_adapt_clause</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clause</span><span class="p">,</span> <span class="n">as_filter</span><span class="p">,</span> <span class="n">orm_only</span><span class="p">):</span>
        <span class="sd">"""Adapt incoming clauses to transformations which</span>
<span class="sd">        have been applied within this query."""</span>

        <span class="n">adapters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># do we adapt all expression elements or only those</span>
        <span class="c1"># tagged as 'ORM' constructs ?</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orm_only_adapt</span><span class="p">:</span>
            <span class="n">orm_only</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">as_filter</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_aliases</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">fa</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_aliases</span><span class="p">:</span>
                <span class="n">adapters</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">orm_only</span><span class="p">,</span> <span class="n">fa</span><span class="o">.</span><span class="n">replace</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj_alias</span><span class="p">:</span>
            <span class="c1"># for the "from obj" alias, apply extra rule to the</span>
            <span class="c1"># 'ORM only' check, if this query were generated from a</span>
            <span class="c1"># subquery of itself, i.e. _from_selectable(), apply adaption</span>
            <span class="c1"># to all SQL constructs.</span>
            <span class="n">adapters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">orm_only</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orm_only_from_obj_alias</span> <span class="k">else</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj_alias</span><span class="o">.</span><span class="n">replace</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polymorphic_adapters</span><span class="p">:</span>
            <span class="n">adapters</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">orm_only</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_polymorphic_element</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">adapters</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">clause</span>

        <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="n">elem</span><span class="p">):</span>
            <span class="n">is_orm_adapt</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">"_orm_adapt"</span> <span class="ow">in</span> <span class="n">elem</span><span class="o">.</span><span class="n">_annotations</span>
                <span class="ow">or</span> <span class="s2">"parententity"</span> <span class="ow">in</span> <span class="n">elem</span><span class="o">.</span><span class="n">_annotations</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">_orm_only</span><span class="p">,</span> <span class="n">adapter</span> <span class="ow">in</span> <span class="n">adapters</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">_orm_only</span> <span class="ow">or</span> <span class="n">is_orm_adapt</span><span class="p">:</span>
                    <span class="n">e</span> <span class="o">=</span> <span class="n">adapter</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">e</span>

        <span class="k">return</span> <span class="n">visitors</span><span class="o">.</span><span class="n">replacement_traverse</span><span class="p">(</span><span class="n">clause</span><span class="p">,</span> <span class="p">{},</span> <span class="n">replace</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_query_entity_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Return the first QueryEntity."""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_mapper_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""return the Mapper associated with the first QueryEntity."""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mapper</span>

    <span class="k">def</span> <span class="nf">_entity_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Return the 'entity' (mapper or AliasedClass) associated</span>
<span class="sd">        with the first QueryEntity, or alternatively the 'select from'</span>
<span class="sd">        entity if specified."""</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_select_from_entity</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_from_entity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_entity_zero</span><span class="p">()</span><span class="o">.</span><span class="n">entity_zero</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_mapper_entities</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ent</span><span class="p">,</span> <span class="n">_MapperEntity</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">ent</span>

    <span class="k">def</span> <span class="nf">_joinpoint_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_joinpoint</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"_joinpoint_entity"</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entity_zero</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_bind_mapper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ezero</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entity_zero</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ezero</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">insp</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">ezero</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">insp</span><span class="o">.</span><span class="n">is_clause_element</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">insp</span><span class="o">.</span><span class="n">mapper</span>

        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_only_full_mapper_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">methname</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span> <span class="o">!=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_primary_entity</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">"</span><span class="si">%s</span><span class="s2">() can only be used against "</span>
                <span class="s2">"a single mapped class."</span> <span class="o">%</span> <span class="n">methname</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_primary_entity</span><span class="o">.</span><span class="n">entity_zero</span>

    <span class="k">def</span> <span class="nf">_only_entity_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rationale</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="n">rationale</span>
                <span class="ow">or</span> <span class="s2">"This operation requires a Query "</span>
                <span class="s2">"against a single mapper."</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entity_zero</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__all_equivs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">equivs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mapper_entities</span><span class="p">:</span>
            <span class="n">equivs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ent</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">_equivalent_columns</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">equivs</span>

    <span class="k">def</span> <span class="nf">_get_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_no_criterion_condition</span><span class="p">(</span>
            <span class="s2">"get"</span><span class="p">,</span> <span class="n">order_by</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">distinct</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_existing_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_no_criterion_assertion</span><span class="p">(</span><span class="s2">"get"</span><span class="p">,</span> <span class="n">order_by</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">distinct</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_no_criterion_assertion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meth</span><span class="p">,</span> <span class="n">order_by</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">distinct</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enable_assertions</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_criterion</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statement</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_by</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">order_by</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">distinct</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distinct</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">"Query.</span><span class="si">%s</span><span class="s2">() being called on a "</span>
                <span class="s2">"Query with existing criterion. "</span> <span class="o">%</span> <span class="n">meth</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_no_criterion_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meth</span><span class="p">,</span> <span class="n">order_by</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">distinct</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_no_criterion_assertion</span><span class="p">(</span><span class="n">meth</span><span class="p">,</span> <span class="n">order_by</span><span class="p">,</span> <span class="n">distinct</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_statement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_criterion</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_by</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distinct</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_no_clauseelement_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meth</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enable_assertions</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">"Query.</span><span class="si">%s</span><span class="s2">() being called on a "</span>
                <span class="s2">"Query with existing criterion. "</span> <span class="o">%</span> <span class="n">meth</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_no_criterion_condition</span><span class="p">(</span><span class="n">meth</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_no_statement_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meth</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enable_assertions</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statement</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="s2">"Query.</span><span class="si">%s</span><span class="s2">() being called on a Query with an existing full "</span>
                    <span class="s2">"statement - can't apply criterion."</span>
                <span class="p">)</span>
                <span class="o">%</span> <span class="n">meth</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_no_limit_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meth</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enable_assertions</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">"Query.</span><span class="si">%s</span><span class="s2">() being called on a Query which already has LIMIT "</span>
                <span class="s2">"or OFFSET applied. To modify the row-limited results of a "</span>
                <span class="s2">" Query, call from_self() first.  "</span>
                <span class="s2">"Otherwise, call </span><span class="si">%s</span><span class="s2">() before limit() or offset() "</span>
                <span class="s2">"are applied."</span> <span class="o">%</span> <span class="p">(</span><span class="n">meth</span><span class="p">,</span> <span class="n">meth</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_options</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">populate_existing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">version_check</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">only_load_props</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">refresh_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">identity_token</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">populate_existing</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_populate_existing</span> <span class="o">=</span> <span class="n">populate_existing</span>
        <span class="k">if</span> <span class="n">version_check</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_version_check</span> <span class="o">=</span> <span class="n">version_check</span>
        <span class="k">if</span> <span class="n">refresh_state</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_refresh_state</span> <span class="o">=</span> <span class="n">refresh_state</span>
        <span class="k">if</span> <span class="n">only_load_props</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_only_load_props</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">only_load_props</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">identity_token</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_refresh_identity_token</span> <span class="o">=</span> <span class="n">identity_token</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">q</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">q</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">statement</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""The full SELECT statement represented by this Query.</span>

<span class="sd">        The statement by default will not have disambiguating labels</span>
<span class="sd">        applied to the construct unless with_labels(True) is called</span>
<span class="sd">        first.</span>

<span class="sd">        """</span>

        <span class="n">stmt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compile_context</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_with_labels</span><span class="p">)</span><span class="o">.</span><span class="n">statement</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="p">:</span>
            <span class="n">stmt</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">stmt</span>

    <span class="k">def</span> <span class="nf">subquery</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">reduce_columns</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""return the full SELECT statement represented by</span>
<span class="sd">        this :class:`.Query`, embedded within an :class:`.Alias`.</span>

<span class="sd">        Eager JOIN generation within the query is disabled.</span>

<span class="sd">        :param name: string name to be assigned as the alias;</span>
<span class="sd">            this is passed through to :meth:`.FromClause.alias`.</span>
<span class="sd">            If ``None``, a name will be deterministically generated</span>
<span class="sd">            at compile time.</span>

<span class="sd">        :param with_labels: if True, :meth:`.with_labels` will be called</span>
<span class="sd">         on the :class:`.Query` first to apply table-qualified labels</span>
<span class="sd">         to all columns.</span>

<span class="sd">        :param reduce_columns: if True, :meth:`.Select.reduce_columns` will</span>
<span class="sd">         be called on the resulting :func:`.select` construct,</span>
<span class="sd">         to remove same-named columns where one also refers to the other</span>
<span class="sd">         via foreign key or WHERE clause equivalence.</span>

<span class="sd">        """</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_eagerloads</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">with_labels</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">with_labels</span><span class="p">()</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">statement</span>

        <span class="k">if</span> <span class="n">reduce_columns</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">reduce_columns</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">q</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cte</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Return the full SELECT statement represented by this</span>
<span class="sd">        :class:`.Query` represented as a common table expression (CTE).</span>

<span class="sd">        Parameters and usage are the same as those of the</span>
<span class="sd">        :meth:`.SelectBase.cte` method; see that method for</span>
<span class="sd">        further details.</span>

<span class="sd">        Here is the `PostgreSQL WITH</span>
<span class="sd">        RECURSIVE example</span>
<span class="sd">        &lt;http://www.postgresql.org/docs/8.4/static/queries-with.html&gt;`_.</span>
<span class="sd">        Note that, in this example, the ``included_parts`` cte and the</span>
<span class="sd">        ``incl_alias`` alias of it are Core selectables, which</span>
<span class="sd">        means the columns are accessed via the ``.c.`` attribute.  The</span>
<span class="sd">        ``parts_alias`` object is an :func:`.orm.aliased` instance of the</span>
<span class="sd">        ``Part`` entity, so column-mapped attributes are available</span>
<span class="sd">        directly::</span>

<span class="sd">            from sqlalchemy.orm import aliased</span>

<span class="sd">            class Part(Base):</span>
<span class="sd">                __tablename__ = 'part'</span>
<span class="sd">                part = Column(String, primary_key=True)</span>
<span class="sd">                sub_part = Column(String, primary_key=True)</span>
<span class="sd">                quantity = Column(Integer)</span>

<span class="sd">            included_parts = session.query(</span>
<span class="sd">                            Part.sub_part,</span>
<span class="sd">                            Part.part,</span>
<span class="sd">                            Part.quantity).\</span>
<span class="sd">                                filter(Part.part=="our part").\</span>
<span class="sd">                                cte(name="included_parts", recursive=True)</span>

<span class="sd">            incl_alias = aliased(included_parts, name="pr")</span>
<span class="sd">            parts_alias = aliased(Part, name="p")</span>
<span class="sd">            included_parts = included_parts.union_all(</span>
<span class="sd">                session.query(</span>
<span class="sd">                    parts_alias.sub_part,</span>
<span class="sd">                    parts_alias.part,</span>
<span class="sd">                    parts_alias.quantity).\</span>
<span class="sd">                        filter(parts_alias.part==incl_alias.c.sub_part)</span>
<span class="sd">                )</span>

<span class="sd">            q = session.query(</span>
<span class="sd">                    included_parts.c.sub_part,</span>
<span class="sd">                    func.sum(included_parts.c.quantity).</span>
<span class="sd">                        label('total_quantity')</span>
<span class="sd">                ).\</span>
<span class="sd">                group_by(included_parts.c.sub_part)</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.HasCTE.cte`</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_eagerloads</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">statement</span><span class="o">.</span><span class="n">cte</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="n">recursive</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">"""Return the full SELECT statement represented by this</span>
<span class="sd">        :class:`.Query`, converted</span>
<span class="sd">        to a scalar subquery with a label of the given name.</span>

<span class="sd">        Analogous to :meth:`sqlalchemy.sql.expression.SelectBase.label`.</span>

<span class="sd">        """</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_eagerloads</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">statement</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">as_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Return the full SELECT statement represented by this</span>
<span class="sd">        :class:`.Query`, converted to a scalar subquery.</span>

<span class="sd">        Analogous to :meth:`sqlalchemy.sql.expression.SelectBase.as_scalar`.</span>

<span class="sd">        """</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_eagerloads</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">statement</span><span class="o">.</span><span class="n">as_scalar</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">selectable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Return the :class:`.Select` object emitted by this :class:`.Query`.</span>

<span class="sd">        Used for :func:`.inspect` compatibility, this is equivalent to::</span>

<span class="sd">            query.enable_eagerloads(False).with_labels().statement</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__clause_element__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__clause_element__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_eagerloads</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">with_labels</span><span class="p">()</span><span class="o">.</span><span class="n">statement</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">only_return_tuples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">"""When set to True, the query results will always be a tuple.</span>

<span class="sd">        This is specifically for single element queries. The default is False.</span>

<span class="sd">        .. versionadded:: 1.2.5</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Query.is_single_entity`</span>

<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_only_return_tuples</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_single_entity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Indicates if this :class:`.Query` returns tuples or single entities.</span>

<span class="sd">        Returns True if this query returns a single entity for each instance</span>
<span class="sd">        in its result list, and False if this query returns a tuple of entities</span>
<span class="sd">        for each result.</span>

<span class="sd">        .. versionadded:: 1.3.11</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Query.only_return_tuples`</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_only_return_tuples</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">supports_single_entity</span>
        <span class="p">)</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">enable_eagerloads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">"""Control whether or not eager joins and subqueries are</span>
<span class="sd">        rendered.</span>

<span class="sd">        When set to False, the returned Query will not render</span>
<span class="sd">        eager joins regardless of :func:`~sqlalchemy.orm.joinedload`,</span>
<span class="sd">        :func:`~sqlalchemy.orm.subqueryload` options</span>
<span class="sd">        or mapper-level ``lazy='joined'``/``lazy='subquery'``</span>
<span class="sd">        configurations.</span>

<span class="sd">        This is used primarily when nesting the Query's</span>
<span class="sd">        statement into a subquery or other</span>
<span class="sd">        selectable, or when using :meth:`.Query.yield_per`.</span>

<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_enable_eagerloads</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_no_yield_per</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
            <span class="s2">"The yield_per Query option is currently not "</span>
            <span class="s2">"compatible with </span><span class="si">%s</span><span class="s2"> eager loading.  Please "</span>
            <span class="s2">"specify lazyload('*') or query.enable_eagerloads(False) in "</span>
            <span class="s2">"order to "</span>
            <span class="s2">"proceed with query.yield_per()."</span> <span class="o">%</span> <span class="n">message</span>
        <span class="p">)</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">with_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Apply column labels to the return value of Query.statement.</span>

<span class="sd">        Indicates that this Query's `statement` accessor should return</span>
<span class="sd">        a SELECT statement that applies labels to all columns in the</span>
<span class="sd">        form &lt;tablename&gt;_&lt;columnname&gt;; this is commonly used to</span>
<span class="sd">        disambiguate columns from multiple tables which have the same</span>
<span class="sd">        name.</span>

<span class="sd">        When the `Query` actually issues SQL to load rows, it always</span>
<span class="sd">        uses column labeling.</span>

<span class="sd">        .. note:: The :meth:`.Query.with_labels` method *only* applies</span>
<span class="sd">           the output of :attr:`.Query.statement`, and *not* to any of</span>
<span class="sd">           the result-row invoking systems of :class:`.Query` itself, e.g.</span>
<span class="sd">           :meth:`.Query.first`, :meth:`.Query.all`, etc.   To execute</span>
<span class="sd">           a query using :meth:`.Query.with_labels`, invoke the</span>
<span class="sd">           :attr:`.Query.statement` using :meth:`.Session.execute`::</span>

<span class="sd">                result = session.execute(query.with_labels().statement)</span>


<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_with_labels</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">enable_assertions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">"""Control whether assertions are generated.</span>

<span class="sd">        When set to False, the returned Query will</span>
<span class="sd">        not assert its state before certain operations,</span>
<span class="sd">        including that LIMIT/OFFSET has not been applied</span>
<span class="sd">        when filter() is called, no criterion exists</span>
<span class="sd">        when get() is called, and no "from_statement()"</span>
<span class="sd">        exists when filter()/order_by()/group_by() etc.</span>
<span class="sd">        is called.  This more permissive mode is used by</span>
<span class="sd">        custom Query subclasses to specify criterion or</span>
<span class="sd">        other modifiers outside of the usual usage patterns.</span>

<span class="sd">        Care should be taken to ensure that the usage</span>
<span class="sd">        pattern is even possible.  A statement applied</span>
<span class="sd">        by from_statement() will override any criterion</span>
<span class="sd">        set by filter() or order_by(), for example.</span>

<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_enable_assertions</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">whereclause</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""A readonly attribute which returns the current WHERE criterion for</span>
<span class="sd">        this Query.</span>

<span class="sd">        This returned value is a SQL expression construct, or ``None`` if no</span>
<span class="sd">        criterion has been established.</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_criterion</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">_with_current_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">"""indicate that this query applies to objects loaded</span>
<span class="sd">        within a certain path.</span>

<span class="sd">        Used by deferred loaders (see strategies.py) which transfer</span>
<span class="sd">        query options from an originating query to a newly generated</span>
<span class="sd">        query intended for the deferred load.</span>

<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_path</span> <span class="o">=</span> <span class="n">path</span>

    <span class="nd">@_generative</span><span class="p">(</span><span class="n">_no_clauseelement_condition</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">with_polymorphic</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">cls_or_mappers</span><span class="p">,</span> <span class="n">selectable</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">polymorphic_on</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">"""Load columns for inheriting classes.</span>

<span class="sd">        :meth:`.Query.with_polymorphic` applies transformations</span>
<span class="sd">        to the "main" mapped class represented by this :class:`.Query`.</span>
<span class="sd">        The "main" mapped class here means the :class:`.Query`</span>
<span class="sd">        object's first argument is a full class, i.e.</span>
<span class="sd">        ``session.query(SomeClass)``. These transformations allow additional</span>
<span class="sd">        tables to be present in the FROM clause so that columns for a</span>
<span class="sd">        joined-inheritance subclass are available in the query, both for the</span>
<span class="sd">        purposes of load-time efficiency as well as the ability to use</span>
<span class="sd">        these columns at query time.</span>

<span class="sd">        See the documentation section :ref:`with_polymorphic` for</span>
<span class="sd">        details on how this method is used.</span>

<span class="sd">        """</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_primary_entity</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">"No primary mapper set up for this Query."</span>
            <span class="p">)</span>
        <span class="n">entity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_clone</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span> <span class="o">=</span> <span class="p">[</span><span class="n">entity</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">entity</span><span class="o">.</span><span class="n">set_with_polymorphic</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">cls_or_mappers</span><span class="p">,</span>
            <span class="n">selectable</span><span class="o">=</span><span class="n">selectable</span><span class="p">,</span>
            <span class="n">polymorphic_on</span><span class="o">=</span><span class="n">polymorphic_on</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">yield_per</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Yield only ``count`` rows at a time.</span>

<span class="sd">        The purpose of this method is when fetching very large result sets</span>
<span class="sd">        (&gt; 10K rows), to batch results in sub-collections and yield them</span>
<span class="sd">        out partially, so that the Python interpreter doesn't need to declare</span>
<span class="sd">        very large areas of memory which is both time consuming and leads</span>
<span class="sd">        to excessive memory use.   The performance from fetching hundreds of</span>
<span class="sd">        thousands of rows can often double when a suitable yield-per setting</span>
<span class="sd">        (e.g. approximately 1000) is used, even with DBAPIs that buffer</span>
<span class="sd">        rows (which are most).</span>

<span class="sd">        The :meth:`.Query.yield_per` method **is not compatible</span>
<span class="sd">        subqueryload eager loading or joinedload eager loading when</span>
<span class="sd">        using collections**.  It is potentially compatible with "select in"</span>
<span class="sd">        eager loading, **provided the database driver supports multiple,</span>
<span class="sd">        independent cursors** (pysqlite and psycopg2 are known to work,</span>
<span class="sd">        MySQL and SQL Server ODBC drivers do not).</span>

<span class="sd">        Therefore in some cases, it may be helpful to disable</span>
<span class="sd">        eager loads, either unconditionally with</span>
<span class="sd">        :meth:`.Query.enable_eagerloads`::</span>

<span class="sd">            q = sess.query(Object).yield_per(100).enable_eagerloads(False)</span>

<span class="sd">        Or more selectively using :func:`.lazyload`; such as with</span>
<span class="sd">        an asterisk to specify the default loader scheme::</span>

<span class="sd">            q = sess.query(Object).yield_per(100).\</span>
<span class="sd">                options(lazyload('*'), joinedload(Object.some_related))</span>

<span class="sd">        .. warning::</span>

<span class="sd">            Use this method with caution; if the same instance is</span>
<span class="sd">            present in more than one batch of rows, end-user changes</span>
<span class="sd">            to attributes will be overwritten.</span>

<span class="sd">            In particular, it's usually impossible to use this setting</span>
<span class="sd">            with eagerly loaded collections (i.e. any lazy='joined' or</span>
<span class="sd">            'subquery') since those collections will be cleared for a</span>
<span class="sd">            new load when encountered in a subsequent result batch.</span>
<span class="sd">            In the case of 'subquery' loading, the full result for all</span>
<span class="sd">            rows is fetched which generally defeats the purpose of</span>
<span class="sd">            :meth:`~sqlalchemy.orm.query.Query.yield_per`.</span>

<span class="sd">            Also note that while</span>
<span class="sd">            :meth:`~sqlalchemy.orm.query.Query.yield_per` will set the</span>
<span class="sd">            ``stream_results`` execution option to True, currently</span>
<span class="sd">            this is only understood by</span>
<span class="sd">            :mod:`~sqlalchemy.dialects.postgresql.psycopg2`,</span>
<span class="sd">            :mod:`~sqlalchemy.dialects.mysql.mysqldb` and</span>
<span class="sd">            :mod:`~sqlalchemy.dialects.mysql.pymysql` dialects</span>
<span class="sd">            which will stream results using server side cursors</span>
<span class="sd">            instead of pre-buffer all rows for this query. Other</span>
<span class="sd">            DBAPIs **pre-buffer all rows** before making them</span>
<span class="sd">            available.  The memory use of raw database rows is much less</span>
<span class="sd">            than that of an ORM-mapped object, but should still be taken into</span>
<span class="sd">            consideration when benchmarking.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Query.enable_eagerloads`</span>

<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_yield_per</span> <span class="o">=</span> <span class="n">count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_execution_options</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execution_options</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
            <span class="p">{</span><span class="s2">"stream_results"</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">"max_row_buffer"</span><span class="p">:</span> <span class="n">count</span><span class="p">}</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ident</span><span class="p">):</span>
        <span class="sd">"""Return an instance based on the given primary key identifier,</span>
<span class="sd">        or ``None`` if not found.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            my_user = session.query(User).get(5)</span>

<span class="sd">            some_object = session.query(VersionedFoo).get((5, 10))</span>

<span class="sd">            some_object = session.query(VersionedFoo).get(</span>
<span class="sd">                {"id": 5, "version_id": 10})</span>

<span class="sd">        :meth:`~.Query.get` is special in that it provides direct</span>
<span class="sd">        access to the identity map of the owning :class:`.Session`.</span>
<span class="sd">        If the given primary key identifier is present</span>
<span class="sd">        in the local identity map, the object is returned</span>
<span class="sd">        directly from this collection and no SQL is emitted,</span>
<span class="sd">        unless the object has been marked fully expired.</span>
<span class="sd">        If not present,</span>
<span class="sd">        a SELECT is performed in order to locate the object.</span>

<span class="sd">        :meth:`~.Query.get` also will perform a check if</span>
<span class="sd">        the object is present in the identity map and</span>
<span class="sd">        marked as expired - a SELECT</span>
<span class="sd">        is emitted to refresh the object as well as to</span>
<span class="sd">        ensure that the row is still present.</span>
<span class="sd">        If not, :class:`~sqlalchemy.orm.exc.ObjectDeletedError` is raised.</span>

<span class="sd">        :meth:`~.Query.get` is only used to return a single</span>
<span class="sd">        mapped instance, not multiple instances or</span>
<span class="sd">        individual column constructs, and strictly</span>
<span class="sd">        on a single primary key value.  The originating</span>
<span class="sd">        :class:`.Query` must be constructed in this way,</span>
<span class="sd">        i.e. against a single mapped entity,</span>
<span class="sd">        with no additional filtering criterion.  Loading</span>
<span class="sd">        options via :meth:`~.Query.options` may be applied</span>
<span class="sd">        however, and will be used if the object is not</span>
<span class="sd">        yet locally present.</span>

<span class="sd">        A lazy-loading, many-to-one attribute configured</span>
<span class="sd">        by :func:`.relationship`, using a simple</span>
<span class="sd">        foreign-key-to-primary-key criterion, will also use an</span>
<span class="sd">        operation equivalent to :meth:`~.Query.get` in order to retrieve</span>
<span class="sd">        the target value from the local identity map</span>
<span class="sd">        before querying the database.  See :doc:`/orm/loading_relationships`</span>
<span class="sd">        for further details on relationship loading.</span>

<span class="sd">        :param ident: A scalar, tuple, or dictionary representing the</span>
<span class="sd">         primary key.  For a composite (e.g. multiple column) primary key,</span>
<span class="sd">         a tuple or dictionary should be passed.</span>

<span class="sd">         For a single-column primary key, the scalar calling form is typically</span>
<span class="sd">         the most expedient.  If the primary key of a row is the value "5",</span>
<span class="sd">         the call looks like::</span>

<span class="sd">            my_object = query.get(5)</span>

<span class="sd">         The tuple form contains primary key values typically in</span>
<span class="sd">         the order in which they correspond to the mapped :class:`.Table`</span>
<span class="sd">         object's primary key columns, or if the</span>
<span class="sd">         :paramref:`.Mapper.primary_key` configuration parameter were used, in</span>
<span class="sd">         the order used for that parameter. For example, if the primary key</span>
<span class="sd">         of a row is represented by the integer</span>
<span class="sd">         digits "5, 10" the call would look like::</span>

<span class="sd">             my_object = query.get((5, 10))</span>

<span class="sd">         The dictionary form should include as keys the mapped attribute names</span>
<span class="sd">         corresponding to each element of the primary key.  If the mapped class</span>
<span class="sd">         has the attributes ``id``, ``version_id`` as the attributes which</span>
<span class="sd">         store the object's primary key value, the call would look like::</span>

<span class="sd">            my_object = query.get({"id": 5, "version_id": 10})</span>

<span class="sd">         .. versionadded:: 1.3 the :meth:`.Query.get` method now optionally</span>
<span class="sd">            accepts a dictionary of attribute names to values in order to</span>
<span class="sd">            indicate a primary key identifier.</span>


<span class="sd">        :return: The object instance, or ``None``.</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_impl</span><span class="p">(</span><span class="n">ident</span><span class="p">,</span> <span class="n">loading</span><span class="o">.</span><span class="n">load_on_pk_identity</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_identity_lookup</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mapper</span><span class="p">,</span>
        <span class="n">primary_key_identity</span><span class="p">,</span>
        <span class="n">identity_token</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">passive</span><span class="o">=</span><span class="n">attributes</span><span class="o">.</span><span class="n">PASSIVE_OFF</span><span class="p">,</span>
        <span class="n">lazy_loaded_from</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">"""Locate an object in the identity map.</span>

<span class="sd">        Given a primary key identity, constructs an identity key and then</span>
<span class="sd">        looks in the session's identity map.  If present, the object may</span>
<span class="sd">        be run through unexpiration rules (e.g. load unloaded attributes,</span>
<span class="sd">        check if was deleted).</span>

<span class="sd">        For performance reasons, while the :class:`.Query` must be</span>
<span class="sd">        instantiated, it may be instantiated with no entities, and the</span>
<span class="sd">        mapper is passed::</span>

<span class="sd">            obj = session.query()._identity_lookup(inspect(SomeClass), (1, ))</span>

<span class="sd">        :param mapper: mapper in use</span>
<span class="sd">        :param primary_key_identity: the primary key we are searching for, as</span>
<span class="sd">         a tuple.</span>
<span class="sd">        :param identity_token: identity token that should be used to create</span>
<span class="sd">         the identity key.  Used as is, however overriding subclasses can</span>
<span class="sd">         repurpose this in order to interpret the value in a special way,</span>
<span class="sd">         such as if None then look among multiple target tokens.</span>
<span class="sd">        :param passive: passive load flag passed to</span>
<span class="sd">         :func:`.loading.get_from_identity`, which impacts the behavior if</span>
<span class="sd">         the object is found; the object may be validated and/or unexpired</span>
<span class="sd">         if the flag allows for SQL to be emitted.</span>
<span class="sd">        :param lazy_loaded_from: an :class:`.InstanceState` that is</span>
<span class="sd">         specifically asking for this identity as a related identity.  Used</span>
<span class="sd">         for sharding schemes where there is a correspondence between an object</span>
<span class="sd">         and a related object being lazy-loaded (or otherwise</span>
<span class="sd">         relationship-loaded).</span>

<span class="sd">         .. versionadded:: 1.2.9</span>

<span class="sd">        :return: None if the object is not found in the identity map, *or*</span>
<span class="sd">         if the object was unexpired and found to have been deleted.</span>
<span class="sd">         if passive flags disallow SQL and the object is expired, returns</span>
<span class="sd">         PASSIVE_NO_RESULT.   In all other cases the instance is returned.</span>

<span class="sd">        .. versionadded:: 1.2.7</span>

<span class="sd">        """</span>

        <span class="n">key</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="n">identity_key_from_primary_key</span><span class="p">(</span>
            <span class="n">primary_key_identity</span><span class="p">,</span> <span class="n">identity_token</span><span class="o">=</span><span class="n">identity_token</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">loading</span><span class="o">.</span><span class="n">get_from_identity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">passive</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primary_key_identity</span><span class="p">,</span> <span class="n">db_load_fn</span><span class="p">,</span> <span class="n">identity_token</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># convert composite types to individual args</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">primary_key_identity</span><span class="p">,</span> <span class="s2">"__composite_values__"</span><span class="p">):</span>
            <span class="n">primary_key_identity</span> <span class="o">=</span> <span class="n">primary_key_identity</span><span class="o">.</span><span class="n">__composite_values__</span><span class="p">()</span>

        <span class="n">mapper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_only_full_mapper_zero</span><span class="p">(</span><span class="s2">"get"</span><span class="p">)</span>

        <span class="n">is_dict</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">primary_key_identity</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dict</span><span class="p">:</span>
            <span class="n">primary_key_identity</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span>
                <span class="n">primary_key_identity</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">primary_key_identity</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mapper</span><span class="o">.</span><span class="n">primary_key</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">"Incorrect number of values in identifier to formulate "</span>
                <span class="s2">"primary key for query.get(); primary key columns are </span><span class="si">%s</span><span class="s2">"</span>
                <span class="o">%</span> <span class="s2">","</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">"'</span><span class="si">%s</span><span class="s2">'"</span> <span class="o">%</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">mapper</span><span class="o">.</span><span class="n">primary_key</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">is_dict</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">primary_key_identity</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="n">primary_key_identity</span><span class="p">[</span><span class="n">prop</span><span class="o">.</span><span class="n">key</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">mapper</span><span class="o">.</span><span class="n">_identity_key_props</span>
                <span class="p">)</span>

            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s2">"Incorrect names of values in identifier to formulate "</span>
                    <span class="s2">"primary key for query.get(); primary key attribute names"</span>
                    <span class="s2">" are </span><span class="si">%s</span><span class="s2">"</span>
                    <span class="o">%</span> <span class="s2">","</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="s2">"'</span><span class="si">%s</span><span class="s2">'"</span> <span class="o">%</span> <span class="n">prop</span><span class="o">.</span><span class="n">key</span>
                        <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">mapper</span><span class="o">.</span><span class="n">_identity_key_props</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_populate_existing</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="n">mapper</span><span class="o">.</span><span class="n">always_refresh</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_for_update_arg</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">):</span>

            <span class="n">instance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_identity_lookup</span><span class="p">(</span>
                <span class="n">mapper</span><span class="p">,</span> <span class="n">primary_key_identity</span><span class="p">,</span> <span class="n">identity_token</span><span class="o">=</span><span class="n">identity_token</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_get_existing_condition</span><span class="p">()</span>
                <span class="c1"># reject calls for id in identity map but class</span>
                <span class="c1"># mismatch.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">instance</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">mapper</span><span class="o">.</span><span class="n">class_</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="k">return</span> <span class="n">instance</span>

        <span class="k">return</span> <span class="n">db_load_fn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primary_key_identity</span><span class="p">)</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">correlate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">"""Return a :class:`.Query` construct which will correlate the given</span>
<span class="sd">        FROM clauses to that of an enclosing :class:`.Query` or</span>
<span class="sd">        :func:`~.expression.select`.</span>

<span class="sd">        The method here accepts mapped classes, :func:`.aliased` constructs,</span>
<span class="sd">        and :func:`.mapper` constructs as arguments, which are resolved into</span>
<span class="sd">        expression constructs, in addition to appropriate expression</span>
<span class="sd">        constructs.</span>

<span class="sd">        The correlation arguments are ultimately passed to</span>
<span class="sd">        :meth:`.Select.correlate` after coercion to expression constructs.</span>

<span class="sd">        The correlation arguments take effect in such cases</span>
<span class="sd">        as when :meth:`.Query.from_self` is used, or when</span>
<span class="sd">        a subquery as returned by :meth:`.Query.subquery` is</span>
<span class="sd">        embedded in another :func:`~.expression.select` construct.</span>

<span class="sd">        """</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_correlate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correlate</span><span class="o">.</span><span class="n">union</span><span class="p">([</span><span class="kc">None</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_correlate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correlate</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
                    <span class="n">sql_util</span><span class="o">.</span><span class="n">surface_selectables</span><span class="p">(</span><span class="n">_interpret_as_from</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
                <span class="p">)</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">autoflush</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">setting</span><span class="p">):</span>
        <span class="sd">"""Return a Query with a specific 'autoflush' setting.</span>

<span class="sd">        Note that a Session with autoflush=False will</span>
<span class="sd">        not autoflush, even if this flag is set to True at the</span>
<span class="sd">        Query level.  Therefore this flag is usually used only</span>
<span class="sd">        to disable autoflush for a specific Query.</span>

<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_autoflush</span> <span class="o">=</span> <span class="n">setting</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">populate_existing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Return a :class:`.Query` that will expire and refresh all instances</span>
<span class="sd">        as they are loaded, or reused from the current :class:`.Session`.</span>

<span class="sd">        :meth:`.populate_existing` does not improve behavior when</span>
<span class="sd">        the ORM is used normally - the :class:`.Session` object's usual</span>
<span class="sd">        behavior of maintaining a transaction and expiring all attributes</span>
<span class="sd">        after rollback or commit handles object state automatically.</span>
<span class="sd">        This method is not intended for general use.</span>

<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_populate_existing</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">_with_invoke_all_eagers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">"""Set the 'invoke all eagers' flag which causes joined- and</span>
<span class="sd">        subquery loaders to traverse into already-loaded related objects</span>
<span class="sd">        and collections.</span>

<span class="sd">        Default is that of :attr:`.Query._invoke_all_eagers`.</span>

<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invoke_all_eagers</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">with_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="nb">property</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">from_entity</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># noqa</span>
        <span class="sd">"""Add filtering criterion that relates the given instance</span>
<span class="sd">        to a child object or collection, using its attribute state</span>
<span class="sd">        as well as an established :func:`.relationship()`</span>
<span class="sd">        configuration.</span>

<span class="sd">        The method uses the :func:`.with_parent` function to generate</span>
<span class="sd">        the clause, the result of which is passed to :meth:`.Query.filter`.</span>

<span class="sd">        Parameters are the same as :func:`.with_parent`, with the exception</span>
<span class="sd">        that the given property can be None, in which case a search is</span>
<span class="sd">        performed against this :class:`.Query` object's target mapper.</span>

<span class="sd">        :param instance:</span>
<span class="sd">          An instance which has some :func:`.relationship`.</span>

<span class="sd">        :param property:</span>
<span class="sd">          String property name, or class-bound attribute, which indicates</span>
<span class="sd">          what relationship from the instance should be used to reconcile the</span>
<span class="sd">          parent/child relationship.</span>

<span class="sd">        :param from_entity:</span>
<span class="sd">          Entity in which to consider as the left side.  This defaults to the</span>
<span class="sd">          "zero" entity of the :class:`.Query` itself.</span>

<span class="sd">        """</span>

        <span class="k">if</span> <span class="n">from_entity</span><span class="p">:</span>
            <span class="n">entity_zero</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">from_entity</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">entity_zero</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entity_zero</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">property</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">mapper</span> <span class="o">=</span> <span class="n">object_mapper</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">mapper</span><span class="o">.</span><span class="n">iterate_properties</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">prop</span><span class="p">,</span> <span class="n">properties</span><span class="o">.</span><span class="n">RelationshipProperty</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="n">prop</span><span class="o">.</span><span class="n">mapper</span> <span class="ow">is</span> <span class="n">entity_zero</span><span class="o">.</span><span class="n">mapper</span>
                <span class="p">):</span>
                    <span class="nb">property</span> <span class="o">=</span> <span class="n">prop</span>  <span class="c1"># noqa</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s2">"Could not locate a property which relates instances "</span>
                    <span class="s2">"of class '</span><span class="si">%s</span><span class="s2">' to instances of class '</span><span class="si">%s</span><span class="s2">'"</span>
                    <span class="o">%</span> <span class="p">(</span>
                        <span class="n">entity_zero</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">class_</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                        <span class="n">instance</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">with_parent</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="nb">property</span><span class="p">,</span> <span class="n">entity_zero</span><span class="o">.</span><span class="n">entity</span><span class="p">))</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">add_entity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entity</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""add a mapped entity to the list of result columns</span>
<span class="sd">        to be returned."""</span>

        <span class="k">if</span> <span class="n">alias</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">entity</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">entity</span><span class="p">,</span> <span class="n">alias</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">_MapperEntity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entity</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_entity_selectables</span><span class="p">([</span><span class="n">m</span><span class="p">])</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">with_session</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">session</span><span class="p">):</span>
        <span class="sd">"""Return a :class:`.Query` that will use the given :class:`.Session`.</span>

<span class="sd">        While the :class:`.Query` object is normally instantiated using the</span>
<span class="sd">        :meth:`.Session.query` method, it is legal to build the :class:`.Query`</span>
<span class="sd">        directly without necessarily using a :class:`.Session`.  Such a</span>
<span class="sd">        :class:`.Query` object, or any :class:`.Query` already associated</span>
<span class="sd">        with a different :class:`.Session`, can produce a new :class:`.Query`</span>
<span class="sd">        object associated with a target session using this method::</span>

<span class="sd">            from sqlalchemy.orm import Query</span>

<span class="sd">            query = Query([MyClass]).filter(MyClass.id == 5)</span>

<span class="sd">            result = query.with_session(my_session).one()</span>

<span class="sd">        """</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="n">session</span>

    <span class="k">def</span> <span class="nf">from_self</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">entities</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""return a Query that selects from this Query's</span>
<span class="sd">        SELECT statement.</span>

<span class="sd">        :meth:`.Query.from_self` essentially turns the SELECT statement</span>
<span class="sd">        into a SELECT of itself.  Given a query such as::</span>

<span class="sd">            q = session.query(User).filter(User.name.like('e%'))</span>

<span class="sd">        Given the :meth:`.Query.from_self` version::</span>

<span class="sd">            q = session.query(User).filter(User.name.like('e%')).from_self()</span>

<span class="sd">        This query renders as:</span>

<span class="sd">        .. sourcecode:: sql</span>

<span class="sd">            SELECT anon_1.user_id AS anon_1_user_id,</span>
<span class="sd">                   anon_1.user_name AS anon_1_user_name</span>
<span class="sd">            FROM (SELECT "user".id AS user_id, "user".name AS user_name</span>
<span class="sd">            FROM "user"</span>
<span class="sd">            WHERE "user".name LIKE :name_1) AS anon_1</span>

<span class="sd">        There are lots of cases where :meth:`.Query.from_self` may be useful.</span>
<span class="sd">        A simple one is where above, we may want to apply a row LIMIT to</span>
<span class="sd">        the set of user objects we query against, and then apply additional</span>
<span class="sd">        joins against that row-limited set::</span>

<span class="sd">            q = session.query(User).filter(User.name.like('e%')).\</span>
<span class="sd">                limit(5).from_self().\</span>
<span class="sd">                join(User.addresses).filter(Address.email.like('q%'))</span>

<span class="sd">        The above query joins to the ``Address`` entity but only against the</span>
<span class="sd">        first five results of the ``User`` query:</span>

<span class="sd">        .. sourcecode:: sql</span>

<span class="sd">            SELECT anon_1.user_id AS anon_1_user_id,</span>
<span class="sd">                   anon_1.user_name AS anon_1_user_name</span>
<span class="sd">            FROM (SELECT "user".id AS user_id, "user".name AS user_name</span>
<span class="sd">            FROM "user"</span>
<span class="sd">            WHERE "user".name LIKE :name_1</span>
<span class="sd">             LIMIT :param_1) AS anon_1</span>
<span class="sd">            JOIN address ON anon_1.user_id = address.user_id</span>
<span class="sd">            WHERE address.email LIKE :email_1</span>

<span class="sd">        **Automatic Aliasing**</span>

<span class="sd">        Another key behavior of :meth:`.Query.from_self` is that it applies</span>
<span class="sd">        **automatic aliasing** to the entities inside the subquery, when</span>
<span class="sd">        they are referenced on the outside.  Above, if we continue to</span>
<span class="sd">        refer to the ``User`` entity without any additional aliasing applied</span>
<span class="sd">        to it, those references wil be in terms of the subquery::</span>

<span class="sd">            q = session.query(User).filter(User.name.like('e%')).\</span>
<span class="sd">                limit(5).from_self().\</span>
<span class="sd">                join(User.addresses).filter(Address.email.like('q%')).\</span>
<span class="sd">                order_by(User.name)</span>

<span class="sd">        The ORDER BY against ``User.name`` is aliased to be in terms of the</span>
<span class="sd">        inner subquery:</span>

<span class="sd">        .. sourcecode:: sql</span>

<span class="sd">            SELECT anon_1.user_id AS anon_1_user_id,</span>
<span class="sd">                   anon_1.user_name AS anon_1_user_name</span>
<span class="sd">            FROM (SELECT "user".id AS user_id, "user".name AS user_name</span>
<span class="sd">            FROM "user"</span>
<span class="sd">            WHERE "user".name LIKE :name_1</span>
<span class="sd">             LIMIT :param_1) AS anon_1</span>
<span class="sd">            JOIN address ON anon_1.user_id = address.user_id</span>
<span class="sd">            WHERE address.email LIKE :email_1 ORDER BY anon_1.user_name</span>

<span class="sd">        The automatic aliasing feature only works in a **limited** way,</span>
<span class="sd">        for simple filters and orderings.   More ambitious constructions</span>
<span class="sd">        such as referring to the entity in joins should prefer to use</span>
<span class="sd">        explicit subquery objects, typically making use of the</span>
<span class="sd">        :meth:`.Query.subquery` method to produce an explicit subquery object.</span>
<span class="sd">        Always test the structure of queries by viewing the SQL to ensure</span>
<span class="sd">        a particular structure does what's expected!</span>

<span class="sd">        **Changing the Entities**</span>

<span class="sd">        :meth:`.Query.from_self` also includes the ability to modify what</span>
<span class="sd">        columns are being queried.   In our example, we want ``User.id``</span>
<span class="sd">        to be queried by the inner query, so that we can join to the</span>
<span class="sd">        ``Address`` entity on the outside, but we only wanted the outer</span>
<span class="sd">        query to return the ``Address.email`` column::</span>

<span class="sd">            q = session.query(User).filter(User.name.like('e%')).\</span>
<span class="sd">                limit(5).from_self(Address.email).\</span>
<span class="sd">                join(User.addresses).filter(Address.email.like('q%'))</span>

<span class="sd">        yielding:</span>

<span class="sd">        .. sourcecode:: sql</span>

<span class="sd">            SELECT address.email AS address_email</span>
<span class="sd">            FROM (SELECT "user".id AS user_id, "user".name AS user_name</span>
<span class="sd">            FROM "user"</span>
<span class="sd">            WHERE "user".name LIKE :name_1</span>
<span class="sd">             LIMIT :param_1) AS anon_1</span>
<span class="sd">            JOIN address ON anon_1.user_id = address.user_id</span>
<span class="sd">            WHERE address.email LIKE :email_1</span>

<span class="sd">        **Looking out for Inner / Outer Columns**</span>

<span class="sd">        Keep in mind that when referring to columns that originate from</span>
<span class="sd">        inside the subquery, we need to ensure they are present in the</span>
<span class="sd">        columns clause of the subquery itself; this is an ordinary aspect of</span>
<span class="sd">        SQL.  For example, if we wanted to load from a joined entity inside</span>
<span class="sd">        the subquery using :func:`.contains_eager`, we need to add those</span>
<span class="sd">        columns.   Below illustrates a join of ``Address`` to ``User``,</span>
<span class="sd">        then a subquery, and then we'd like :func:`.contains_eager` to access</span>
<span class="sd">        the ``User`` columns::</span>

<span class="sd">            q = session.query(Address).join(Address.user).\</span>
<span class="sd">                filter(User.name.like('e%'))</span>

<span class="sd">            q = q.add_entity(User).from_self().\</span>
<span class="sd">                options(contains_eager(Address.user))</span>

<span class="sd">        We use :meth:`.Query.add_entity` above **before** we call</span>
<span class="sd">        :meth:`.Query.from_self` so that the ``User`` columns are present</span>
<span class="sd">        in the inner subquery, so that they are available to the</span>
<span class="sd">        :func:`.contains_eager` modifier we are using on the outside,</span>
<span class="sd">        producing:</span>

<span class="sd">        .. sourcecode:: sql</span>

<span class="sd">            SELECT anon_1.address_id AS anon_1_address_id,</span>
<span class="sd">                   anon_1.address_email AS anon_1_address_email,</span>
<span class="sd">                   anon_1.address_user_id AS anon_1_address_user_id,</span>
<span class="sd">                   anon_1.user_id AS anon_1_user_id,</span>
<span class="sd">                   anon_1.user_name AS anon_1_user_name</span>
<span class="sd">            FROM (</span>
<span class="sd">                SELECT address.id AS address_id,</span>
<span class="sd">                address.email AS address_email,</span>
<span class="sd">                address.user_id AS address_user_id,</span>
<span class="sd">                "user".id AS user_id,</span>
<span class="sd">                "user".name AS user_name</span>
<span class="sd">            FROM address JOIN "user" ON "user".id = address.user_id</span>
<span class="sd">            WHERE "user".name LIKE :name_1) AS anon_1</span>

<span class="sd">        If we didn't call ``add_entity(User)``, but still asked</span>
<span class="sd">        :func:`.contains_eager` to load the ``User`` entity, it would be</span>
<span class="sd">        forced to add the table on the outside without the correct</span>
<span class="sd">        join criteria - note the ``anon1, "user"`` phrase at</span>
<span class="sd">        the end:</span>

<span class="sd">        .. sourcecode:: sql</span>

<span class="sd">            -- incorrect query</span>
<span class="sd">            SELECT anon_1.address_id AS anon_1_address_id,</span>
<span class="sd">                   anon_1.address_email AS anon_1_address_email,</span>
<span class="sd">                   anon_1.address_user_id AS anon_1_address_user_id,</span>
<span class="sd">                   "user".id AS user_id,</span>
<span class="sd">                   "user".name AS user_name</span>
<span class="sd">            FROM (</span>
<span class="sd">                SELECT address.id AS address_id,</span>
<span class="sd">                address.email AS address_email,</span>
<span class="sd">                address.user_id AS address_user_id</span>
<span class="sd">            FROM address JOIN "user" ON "user".id = address.user_id</span>
<span class="sd">            WHERE "user".name LIKE :name_1) AS anon_1, "user"</span>

<span class="sd">        :param \*entities: optional list of entities which will replace</span>
<span class="sd">         those being selected.</span>

<span class="sd">        """</span>
        <span class="n">fromclause</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">with_labels</span><span class="p">()</span>
            <span class="o">.</span><span class="n">enable_eagerloads</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="o">.</span><span class="n">statement</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_selectable</span><span class="p">(</span><span class="n">fromclause</span><span class="p">)</span>
        <span class="n">q</span><span class="o">.</span><span class="n">_enable_single_crit</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">q</span><span class="o">.</span><span class="n">_select_from_entity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entity_zero</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">entities</span><span class="p">:</span>
            <span class="n">q</span><span class="o">.</span><span class="n">_set_entities</span><span class="p">(</span><span class="n">entities</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">q</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">_set_enable_single_crit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_enable_single_crit</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">_from_selectable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fromclause</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="s2">"_statement"</span><span class="p">,</span>
            <span class="s2">"_criterion"</span><span class="p">,</span>
            <span class="s2">"_order_by"</span><span class="p">,</span>
            <span class="s2">"_group_by"</span><span class="p">,</span>
            <span class="s2">"_limit"</span><span class="p">,</span>
            <span class="s2">"_offset"</span><span class="p">,</span>
            <span class="s2">"_joinpath"</span><span class="p">,</span>
            <span class="s2">"_joinpoint"</span><span class="p">,</span>
            <span class="s2">"_distinct"</span><span class="p">,</span>
            <span class="s2">"_having"</span><span class="p">,</span>
            <span class="s2">"_prefixes"</span><span class="p">,</span>
            <span class="s2">"_suffixes"</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_select_from</span><span class="p">([</span><span class="n">fromclause</span><span class="p">],</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># this enables clause adaptation for non-ORM</span>
        <span class="c1"># expressions.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orm_only_from_obj_alias</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">old_entities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">old_entities</span><span class="p">:</span>
            <span class="n">e</span><span class="o">.</span><span class="n">adapt_to_selectable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">columns</span><span class="p">):</span>
        <span class="sd">"""Return an iterator yielding result tuples corresponding</span>
<span class="sd">        to the given list of columns"""</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">columns</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">(())</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">()</span>
        <span class="n">q</span><span class="o">.</span><span class="n">_set_entities</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">entity_wrapper</span><span class="o">=</span><span class="n">_ColumnEntity</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">q</span><span class="o">.</span><span class="n">_yield_per</span><span class="p">:</span>
            <span class="n">q</span><span class="o">.</span><span class="n">_yield_per</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

    <span class="n">_values</span> <span class="o">=</span> <span class="n">values</span>

    <span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="sd">"""Return a scalar result corresponding to the given</span>
<span class="sd">        column expression."""</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">column</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">with_entities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">entities</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Return a new :class:`.Query` replacing the SELECT list with the</span>
<span class="sd">        given entities.</span>

<span class="sd">        e.g.::</span>

<span class="sd">            # Users, filtered on some arbitrary criterion</span>
<span class="sd">            # and then ordered by related email address</span>
<span class="sd">            q = session.query(User).\</span>
<span class="sd">                        join(User.address).\</span>
<span class="sd">                        filter(User.name.like('%ed%')).\</span>
<span class="sd">                        order_by(Address.email)</span>

<span class="sd">            # given *only* User.id==5, Address.email, and 'q', what</span>
<span class="sd">            # would the *next* User in the result be ?</span>
<span class="sd">            subq = q.with_entities(Address.email).\</span>
<span class="sd">                        order_by(None).\</span>
<span class="sd">                        filter(User.id==5).\</span>
<span class="sd">                        subquery()</span>
<span class="sd">            q = q.join((subq, subq.c.email &lt; Address.email)).\</span>
<span class="sd">                        limit(1)</span>

<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_entities</span><span class="p">(</span><span class="n">entities</span><span class="p">)</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">add_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">column</span><span class="p">):</span>
        <span class="sd">"""Add one or more column expressions to the list</span>
<span class="sd">        of result columns to be returned."""</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">column</span><span class="p">:</span>
            <span class="n">_ColumnEntity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="c1"># _ColumnEntity may add many entities if the</span>
        <span class="c1"># given arg is a FROM clause</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_entity_selectables</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">[</span><span class="n">l</span><span class="p">:])</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">pending_deprecation</span><span class="p">(</span>
        <span class="s2">"0.7"</span><span class="p">,</span>
        <span class="s2">":meth:`.add_column` is superseded "</span> <span class="s2">"by :meth:`.add_columns`"</span><span class="p">,</span>
        <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">add_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="sd">"""Add a column expression to the list of result columns to be</span>
<span class="sd">        returned.</span>

<span class="sd">        Pending deprecation: :meth:`.add_column` will be superseded by</span>
<span class="sd">        :meth:`.add_columns`.</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_columns</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">"""Return a new :class:`.Query` object, applying the given list of</span>
<span class="sd">        mapper options.</span>

<span class="sd">        Most supplied options regard changing how column- and</span>
<span class="sd">        relationship-mapped attributes are loaded.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`deferred_options`</span>

<span class="sd">            :ref:`relationship_loader_options`</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_conditional_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conditional</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="c1"># most MapperOptions write to the '_attributes' dictionary,</span>
        <span class="c1"># so copy that as well</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attributes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attributes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="s2">"_unbound_load_dedupes"</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attributes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_attributes</span><span class="p">[</span><span class="s2">"_unbound_load_dedupes"</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">flatten_iterator</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_with_options</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_with_options</span> <span class="o">+</span> <span class="n">opts</span>
        <span class="k">if</span> <span class="n">conditional</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">opt</span> <span class="ow">in</span> <span class="n">opts</span><span class="p">:</span>
                <span class="n">opt</span><span class="o">.</span><span class="n">process_query_conditionally</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">opt</span> <span class="ow">in</span> <span class="n">opts</span><span class="p">:</span>
                <span class="n">opt</span><span class="o">.</span><span class="n">process_query</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">with_transformation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">):</span>
        <span class="sd">"""Return a new :class:`.Query` object transformed by</span>
<span class="sd">        the given function.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            def filter_something(criterion):</span>
<span class="sd">                def transform(q):</span>
<span class="sd">                    return q.filter(criterion)</span>
<span class="sd">                return transform</span>

<span class="sd">            q = q.with_transformation(filter_something(x==5))</span>

<span class="sd">        This allows ad-hoc recipes to be created for :class:`.Query`</span>
<span class="sd">        objects.  See the example at :ref:`hybrid_transformers`.</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">with_hint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selectable</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">dialect_name</span><span class="o">=</span><span class="s2">"*"</span><span class="p">):</span>
        <span class="sd">"""Add an indexing or other executional context</span>
<span class="sd">        hint for the given entity or selectable to</span>
<span class="sd">        this :class:`.Query`.</span>

<span class="sd">        Functionality is passed straight through to</span>
<span class="sd">        :meth:`~sqlalchemy.sql.expression.Select.with_hint`,</span>
<span class="sd">        with the addition that ``selectable`` can be a</span>
<span class="sd">        :class:`.Table`, :class:`.Alias`, or ORM entity / mapped class</span>
<span class="sd">        /etc.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Query.with_statement_hint`</span>

<span class="sd">            :meth:.`.Query.prefix_with` - generic SELECT prefixing which also</span>
<span class="sd">            can suit some database-specific HINT syntaxes such as MySQL</span>
<span class="sd">            optimizer hints</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">selectable</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">selectable</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">selectable</span><span class="p">)</span><span class="o">.</span><span class="n">selectable</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_with_hints</span> <span class="o">+=</span> <span class="p">((</span><span class="n">selectable</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">dialect_name</span><span class="p">),)</span>

    <span class="k">def</span> <span class="nf">with_statement_hint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">dialect_name</span><span class="o">=</span><span class="s2">"*"</span><span class="p">):</span>
        <span class="sd">"""add a statement hint to this :class:`.Select`.</span>

<span class="sd">        This method is similar to :meth:`.Select.with_hint` except that</span>
<span class="sd">        it does not require an individual table, and instead applies to the</span>
<span class="sd">        statement as a whole.</span>

<span class="sd">        This feature calls down into :meth:`.Select.with_statement_hint`.</span>

<span class="sd">        .. versionadded:: 1.0.0</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Query.with_hint`</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_hint</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">dialect_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_execution_options</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">""" Get the non-SQL options which will take effect during execution.</span>

<span class="sd">        .. versionadded:: 1.3</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Query.execution_options`</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execution_options</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">execution_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">""" Set non-SQL options which take effect during execution.</span>

<span class="sd">        The options are the same as those accepted by</span>
<span class="sd">        :meth:`.Connection.execution_options`.</span>

<span class="sd">        Note that the ``stream_results`` execution option is enabled</span>
<span class="sd">        automatically if the :meth:`~sqlalchemy.orm.query.Query.yield_per()`</span>
<span class="sd">        method is used.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Query.get_execution_options`</span>

<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_execution_options</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execution_options</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="nd">@util</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span>
        <span class="s2">"0.9"</span><span class="p">,</span>
        <span class="s2">"The :meth:`.Query.with_lockmode` method is deprecated and will "</span>
        <span class="s2">"be removed in a future release.  Please refer to "</span>
        <span class="s2">":meth:`.Query.with_for_update`. "</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">with_lockmode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="sd">"""Return a new :class:`.Query` object with the specified "locking mode",</span>
<span class="sd">        which essentially refers to the ``FOR UPDATE`` clause.</span>

<span class="sd">        :param mode: a string representing the desired locking mode.</span>
<span class="sd">         Valid values are:</span>

<span class="sd">         * ``None`` - translates to no lockmode</span>

<span class="sd">         * ``'update'`` - translates to ``FOR UPDATE``</span>
<span class="sd">           (standard SQL, supported by most dialects)</span>

<span class="sd">         * ``'update_nowait'`` - translates to ``FOR UPDATE NOWAIT``</span>
<span class="sd">           (supported by Oracle, PostgreSQL 8.1 upwards)</span>

<span class="sd">         * ``'read'`` - translates to ``LOCK IN SHARE MODE`` (for MySQL),</span>
<span class="sd">           and ``FOR SHARE`` (for PostgreSQL)</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Query.with_for_update` - improved API for</span>
<span class="sd">            specifying the ``FOR UPDATE`` clause.</span>

<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_for_update_arg</span> <span class="o">=</span> <span class="n">LockmodeArg</span><span class="o">.</span><span class="n">parse_legacy_query</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">with_for_update</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">read</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">nowait</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">of</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">skip_locked</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">key_share</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">"""return a new :class:`.Query` with the specified options for the</span>
<span class="sd">        ``FOR UPDATE`` clause.</span>

<span class="sd">        The behavior of this method is identical to that of</span>
<span class="sd">        :meth:`.SelectBase.with_for_update`.  When called with no arguments,</span>
<span class="sd">        the resulting ``SELECT`` statement will have a ``FOR UPDATE`` clause</span>
<span class="sd">        appended.  When additional arguments are specified, backend-specific</span>
<span class="sd">        options such as ``FOR UPDATE NOWAIT`` or ``LOCK IN SHARE MODE``</span>
<span class="sd">        can take effect.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            q = sess.query(User).with_for_update(nowait=True, of=User)</span>

<span class="sd">        The above query on a PostgreSQL backend will render like::</span>

<span class="sd">            SELECT users.id AS users_id FROM users FOR UPDATE OF users NOWAIT</span>

<span class="sd">        .. versionadded:: 0.9.0 :meth:`.Query.with_for_update` supersedes</span>
<span class="sd">           the :meth:`.Query.with_lockmode` method.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.GenerativeSelect.with_for_update` - Core level method with</span>
<span class="sd">            full argument and behavioral description.</span>

<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_for_update_arg</span> <span class="o">=</span> <span class="n">LockmodeArg</span><span class="p">(</span>
            <span class="n">read</span><span class="o">=</span><span class="n">read</span><span class="p">,</span>
            <span class="n">nowait</span><span class="o">=</span><span class="n">nowait</span><span class="p">,</span>
            <span class="n">of</span><span class="o">=</span><span class="n">of</span><span class="p">,</span>
            <span class="n">skip_locked</span><span class="o">=</span><span class="n">skip_locked</span><span class="p">,</span>
            <span class="n">key_share</span><span class="o">=</span><span class="n">key_share</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""add values for bind parameters which may have been</span>
<span class="sd">        specified in filter().</span>

<span class="sd">        parameters may be specified using \**kwargs, or optionally a single</span>
<span class="sd">        dictionary as the first positional argument. The reason for both is</span>
<span class="sd">        that \**kwargs is convenient, however some parameter dictionaries</span>
<span class="sd">        contain unicode keys in which case \**kwargs cannot be used.</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                <span class="s2">"params() takes zero or one positional argument, "</span>
                <span class="s2">"which is a dictionary."</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@_generative</span><span class="p">(</span><span class="n">_no_statement_condition</span><span class="p">,</span> <span class="n">_no_limit_offset</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">criterion</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""apply the given filtering criterion to a copy</span>
<span class="sd">        of this :class:`.Query`, using SQL expressions.</span>

<span class="sd">        e.g.::</span>

<span class="sd">            session.query(MyClass).filter(MyClass.name == 'some name')</span>

<span class="sd">        Multiple criteria may be specified as comma separated; the effect</span>
<span class="sd">        is that they will be joined together using the :func:`.and_`</span>
<span class="sd">        function::</span>

<span class="sd">            session.query(MyClass).\</span>
<span class="sd">                filter(MyClass.name == 'some name', MyClass.id &gt; 5)</span>

<span class="sd">        The criterion is any SQL expression object applicable to the</span>
<span class="sd">        WHERE clause of a select.   String expressions are coerced</span>
<span class="sd">        into SQL expression constructs via the :func:`.text` construct.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Query.filter_by` - filter on keyword expressions.</span>

<span class="sd">        """</span>
        <span class="k">for</span> <span class="n">criterion</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">criterion</span><span class="p">):</span>
            <span class="n">criterion</span> <span class="o">=</span> <span class="n">expression</span><span class="o">.</span><span class="n">_expression_literal_as_text</span><span class="p">(</span><span class="n">criterion</span><span class="p">)</span>

            <span class="n">criterion</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_clause</span><span class="p">(</span><span class="n">criterion</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_criterion</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_criterion</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_criterion</span> <span class="o">&amp;</span> <span class="n">criterion</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_criterion</span> <span class="o">=</span> <span class="n">criterion</span>

    <span class="k">def</span> <span class="nf">filter_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""apply the given filtering criterion to a copy</span>
<span class="sd">        of this :class:`.Query`, using keyword expressions.</span>

<span class="sd">        e.g.::</span>

<span class="sd">            session.query(MyClass).filter_by(name = 'some name')</span>

<span class="sd">        Multiple criteria may be specified as comma separated; the effect</span>
<span class="sd">        is that they will be joined together using the :func:`.and_`</span>
<span class="sd">        function::</span>

<span class="sd">            session.query(MyClass).\</span>
<span class="sd">                filter_by(name = 'some name', id = 5)</span>

<span class="sd">        The keyword expressions are extracted from the primary</span>
<span class="sd">        entity of the query, or the last entity that was the</span>
<span class="sd">        target of a call to :meth:`.Query.join`.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Query.filter` - filter on SQL expressions.</span>

<span class="sd">        """</span>

        <span class="n">clauses</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">_entity_descriptor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_joinpoint_zero</span><span class="p">(),</span> <span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">value</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="o">*</span><span class="n">clauses</span><span class="p">)</span>

    <span class="nd">@_generative</span><span class="p">(</span><span class="n">_no_statement_condition</span><span class="p">,</span> <span class="n">_no_limit_offset</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">order_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">criterion</span><span class="p">):</span>
        <span class="sd">"""apply one or more ORDER BY criterion to the query and return</span>
<span class="sd">        the newly resulting ``Query``</span>

<span class="sd">        All existing ORDER BY settings can be suppressed by</span>
<span class="sd">        passing ``None`` - this will suppress any ordering configured</span>
<span class="sd">        on the :func:`.mapper` object using the deprecated</span>
<span class="sd">        :paramref:`.mapper.order_by` parameter.</span>

<span class="sd">        """</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">criterion</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">criterion</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">"_order_by"</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">criterion</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">return</span>

        <span class="n">criterion</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_col_list</span><span class="p">(</span><span class="n">criterion</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span> <span class="o">=</span> <span class="n">criterion</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span> <span class="o">+</span> <span class="n">criterion</span>

    <span class="nd">@_generative</span><span class="p">(</span><span class="n">_no_statement_condition</span><span class="p">,</span> <span class="n">_no_limit_offset</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">group_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">criterion</span><span class="p">):</span>
        <span class="sd">"""apply one or more GROUP BY criterion to the query and return</span>
<span class="sd">        the newly resulting :class:`.Query`</span>

<span class="sd">        All existing GROUP BY settings can be suppressed by</span>
<span class="sd">        passing ``None`` - this will suppress any GROUP BY configured</span>
<span class="sd">        on mappers as well.</span>

<span class="sd">        .. versionadded:: 1.1 GROUP BY can be cancelled by passing None,</span>
<span class="sd">           in the same way as ORDER BY.</span>

<span class="sd">        """</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">criterion</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">criterion</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_group_by</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">return</span>

        <span class="n">criterion</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">_orm_columns</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">criterion</span><span class="p">]))</span>
        <span class="n">criterion</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_col_list</span><span class="p">(</span><span class="n">criterion</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_by</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_group_by</span> <span class="o">=</span> <span class="n">criterion</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_group_by</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_by</span> <span class="o">+</span> <span class="n">criterion</span>

    <span class="nd">@_generative</span><span class="p">(</span><span class="n">_no_statement_condition</span><span class="p">,</span> <span class="n">_no_limit_offset</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">having</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">criterion</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""apply a HAVING criterion to the query and return the</span>
<span class="sd">        newly resulting :class:`.Query`.</span>

<span class="sd">        :meth:`~.Query.having` is used in conjunction with</span>
<span class="sd">        :meth:`~.Query.group_by`.</span>

<span class="sd">        HAVING criterion makes it possible to use filters on aggregate</span>
<span class="sd">        functions like COUNT, SUM, AVG, MAX, and MIN, eg.::</span>

<span class="sd">            q = session.query(User.id).\</span>
<span class="sd">                        join(User.addresses).\</span>
<span class="sd">                        group_by(User.id).\</span>
<span class="sd">                        having(func.count(Address.id) &gt; 2)</span>

<span class="sd">        """</span>

        <span class="n">criterion</span> <span class="o">=</span> <span class="n">expression</span><span class="o">.</span><span class="n">_expression_literal_as_text</span><span class="p">(</span><span class="n">criterion</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">criterion</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">criterion</span><span class="p">,</span> <span class="n">sql</span><span class="o">.</span><span class="n">ClauseElement</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                <span class="s2">"having() argument must be of type "</span>
                <span class="s2">"sqlalchemy.sql.ClauseElement or string"</span>
            <span class="p">)</span>

        <span class="n">criterion</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_clause</span><span class="p">(</span><span class="n">criterion</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_having</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_having</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_having</span> <span class="o">&amp;</span> <span class="n">criterion</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_having</span> <span class="o">=</span> <span class="n">criterion</span>

    <span class="k">def</span> <span class="nf">_set_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr_fn</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_selectable</span><span class="p">(</span>
            <span class="n">expr_fn</span><span class="p">(</span><span class="o">*</span><span class="p">([</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">q</span><span class="p">)))</span>
        <span class="p">)</span><span class="o">.</span><span class="n">_set_enable_single_crit</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">):</span>
        <span class="sd">"""Produce a UNION of this Query against one or more queries.</span>

<span class="sd">        e.g.::</span>

<span class="sd">            q1 = sess.query(SomeClass).filter(SomeClass.foo=='bar')</span>
<span class="sd">            q2 = sess.query(SomeClass).filter(SomeClass.bar=='foo')</span>

<span class="sd">            q3 = q1.union(q2)</span>

<span class="sd">        The method accepts multiple Query objects so as to control</span>
<span class="sd">        the level of nesting.  A series of ``union()`` calls such as::</span>

<span class="sd">            x.union(y).union(z).all()</span>

<span class="sd">        will nest on each ``union()``, and produces::</span>

<span class="sd">            SELECT * FROM (SELECT * FROM (SELECT * FROM X UNION</span>
<span class="sd">                            SELECT * FROM y) UNION SELECT * FROM Z)</span>

<span class="sd">        Whereas::</span>

<span class="sd">            x.union(y, z).all()</span>

<span class="sd">        produces::</span>

<span class="sd">            SELECT * FROM (SELECT * FROM X UNION SELECT * FROM y UNION</span>
<span class="sd">                            SELECT * FROM Z)</span>

<span class="sd">        Note that many database backends do not allow ORDER BY to</span>
<span class="sd">        be rendered on a query called within UNION, EXCEPT, etc.</span>
<span class="sd">        To disable all ORDER BY clauses including those configured</span>
<span class="sd">        on mappers, issue ``query.order_by(None)`` - the resulting</span>
<span class="sd">        :class:`.Query` object will not render ORDER BY within</span>
<span class="sd">        its SELECT statement.</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_op</span><span class="p">(</span><span class="n">expression</span><span class="o">.</span><span class="n">union</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">union_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">):</span>
        <span class="sd">"""Produce a UNION ALL of this Query against one or more queries.</span>

<span class="sd">        Works the same way as :meth:`~sqlalchemy.orm.query.Query.union`. See</span>
<span class="sd">        that method for usage examples.</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_op</span><span class="p">(</span><span class="n">expression</span><span class="o">.</span><span class="n">union_all</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">):</span>
        <span class="sd">"""Produce an INTERSECT of this Query against one or more queries.</span>

<span class="sd">        Works the same way as :meth:`~sqlalchemy.orm.query.Query.union`. See</span>
<span class="sd">        that method for usage examples.</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_op</span><span class="p">(</span><span class="n">expression</span><span class="o">.</span><span class="n">intersect</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">intersect_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">):</span>
        <span class="sd">"""Produce an INTERSECT ALL of this Query against one or more queries.</span>

<span class="sd">        Works the same way as :meth:`~sqlalchemy.orm.query.Query.union`. See</span>
<span class="sd">        that method for usage examples.</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_op</span><span class="p">(</span><span class="n">expression</span><span class="o">.</span><span class="n">intersect_all</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">except_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">):</span>
        <span class="sd">"""Produce an EXCEPT of this Query against one or more queries.</span>

<span class="sd">        Works the same way as :meth:`~sqlalchemy.orm.query.Query.union`. See</span>
<span class="sd">        that method for usage examples.</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_op</span><span class="p">(</span><span class="n">expression</span><span class="o">.</span><span class="n">except_</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">except_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">):</span>
        <span class="sd">"""Produce an EXCEPT ALL of this Query against one or more queries.</span>

<span class="sd">        Works the same way as :meth:`~sqlalchemy.orm.query.Query.union`. See</span>
<span class="sd">        that method for usage examples.</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_op</span><span class="p">(</span><span class="n">expression</span><span class="o">.</span><span class="n">except_all</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">props</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Create a SQL JOIN against this :class:`.Query` object's criterion</span>
<span class="sd">        and apply generatively, returning the newly resulting :class:`.Query`.</span>

<span class="sd">        **Simple Relationship Joins**</span>

<span class="sd">        Consider a mapping between two classes ``User`` and ``Address``,</span>
<span class="sd">        with a relationship ``User.addresses`` representing a collection</span>
<span class="sd">        of ``Address`` objects associated with each ``User``.   The most</span>
<span class="sd">        common usage of :meth:`~.Query.join` is to create a JOIN along this</span>
<span class="sd">        relationship, using the ``User.addresses`` attribute as an indicator</span>
<span class="sd">        for how this should occur::</span>

<span class="sd">            q = session.query(User).join(User.addresses)</span>

<span class="sd">        Where above, the call to :meth:`~.Query.join` along ``User.addresses``</span>
<span class="sd">        will result in SQL equivalent to::</span>

<span class="sd">            SELECT user.* FROM user JOIN address ON user.id = address.user_id</span>

<span class="sd">        In the above example we refer to ``User.addresses`` as passed to</span>
<span class="sd">        :meth:`~.Query.join` as the *on clause*, that is, it indicates</span>
<span class="sd">        how the "ON" portion of the JOIN should be constructed.  For a</span>
<span class="sd">        single-entity query such as the one above (i.e. we start by selecting</span>
<span class="sd">        only from ``User`` and nothing else), the relationship can also be</span>
<span class="sd">        specified by its string name::</span>

<span class="sd">            q = session.query(User).join("addresses")</span>

<span class="sd">        :meth:`~.Query.join` can also accommodate multiple</span>
<span class="sd">        "on clause" arguments to produce a chain of joins, such as below</span>
<span class="sd">        where a join across four related entities is constructed::</span>

<span class="sd">            q = session.query(User).join("orders", "items", "keywords")</span>

<span class="sd">        The above would be shorthand for three separate calls to</span>
<span class="sd">        :meth:`~.Query.join`, each using an explicit attribute to indicate</span>
<span class="sd">        the source entity::</span>

<span class="sd">            q = session.query(User).\</span>
<span class="sd">                    join(User.orders).\</span>
<span class="sd">                    join(Order.items).\</span>
<span class="sd">                    join(Item.keywords)</span>

<span class="sd">        **Joins to a Target Entity or Selectable**</span>

<span class="sd">        A second form of :meth:`~.Query.join` allows any mapped entity</span>
<span class="sd">        or core selectable construct as a target.   In this usage,</span>
<span class="sd">        :meth:`~.Query.join` will attempt</span>
<span class="sd">        to create a JOIN along the natural foreign key relationship between</span>
<span class="sd">        two entities::</span>

<span class="sd">            q = session.query(User).join(Address)</span>

<span class="sd">        The above calling form of :meth:`~.Query.join` will raise an error if</span>
<span class="sd">        either there are no foreign keys between the two entities, or if</span>
<span class="sd">        there are multiple foreign key linkages between them.   In the</span>
<span class="sd">        above calling form, :meth:`~.Query.join` is called upon to</span>
<span class="sd">        create the "on clause" automatically for us.  The target can</span>
<span class="sd">        be any mapped entity or selectable, such as a :class:`.Table`::</span>

<span class="sd">            q = session.query(User).join(addresses_table)</span>

<span class="sd">        **Joins to a Target with an ON Clause**</span>

<span class="sd">        The third calling form allows both the target entity as well</span>
<span class="sd">        as the ON clause to be passed explicitly.   Suppose for</span>
<span class="sd">        example we wanted to join to ``Address`` twice, using</span>
<span class="sd">        an alias the second time.  We use :func:`~sqlalchemy.orm.aliased`</span>
<span class="sd">        to create a distinct alias of ``Address``, and join</span>
<span class="sd">        to it using the ``target, onclause`` form, so that the</span>
<span class="sd">        alias can be specified explicitly as the target along with</span>
<span class="sd">        the relationship to instruct how the ON clause should proceed::</span>

<span class="sd">            a_alias = aliased(Address)</span>

<span class="sd">            q = session.query(User).\</span>
<span class="sd">                    join(User.addresses).\</span>
<span class="sd">                    join(a_alias, User.addresses).\</span>
<span class="sd">                    filter(Address.email_address=='ed@foo.com').\</span>
<span class="sd">                    filter(a_alias.email_address=='ed@bar.com')</span>

<span class="sd">        Where above, the generated SQL would be similar to::</span>

<span class="sd">            SELECT user.* FROM user</span>
<span class="sd">                JOIN address ON user.id = address.user_id</span>
<span class="sd">                JOIN address AS address_1 ON user.id=address_1.user_id</span>
<span class="sd">                WHERE address.email_address = :email_address_1</span>
<span class="sd">                AND address_1.email_address = :email_address_2</span>

<span class="sd">        The two-argument calling form of :meth:`~.Query.join`</span>
<span class="sd">        also allows us to construct arbitrary joins with SQL-oriented</span>
<span class="sd">        "on clause" expressions, not relying upon configured relationships</span>
<span class="sd">        at all.  Any SQL expression can be passed as the ON clause</span>
<span class="sd">        when using the two-argument form, which should refer to the target</span>
<span class="sd">        entity in some way as well as an applicable source entity::</span>

<span class="sd">            q = session.query(User).join(Address, User.id==Address.user_id)</span>

<span class="sd">        **Advanced Join Targeting and Adaption**</span>

<span class="sd">        There is a lot of flexibility in what the "target" can be when using</span>
<span class="sd">        :meth:`~.Query.join`.   As noted previously, it also accepts</span>
<span class="sd">        :class:`.Table` constructs and other selectables such as</span>
<span class="sd">        :func:`.alias` and :func:`.select` constructs, with either the one</span>
<span class="sd">        or two-argument forms::</span>

<span class="sd">            addresses_q = select([Address.user_id]).\</span>
<span class="sd">                        where(Address.email_address.endswith("@bar.com")).\</span>
<span class="sd">                        alias()</span>

<span class="sd">            q = session.query(User).\</span>
<span class="sd">                        join(addresses_q, addresses_q.c.user_id==User.id)</span>

<span class="sd">        :meth:`~.Query.join` also features the ability to *adapt* a</span>
<span class="sd">        :meth:`~sqlalchemy.orm.relationship` -driven ON clause to the target</span>
<span class="sd">        selectable. Below we construct a JOIN from ``User`` to a subquery</span>
<span class="sd">        against ``Address``, allowing the relationship denoted by</span>
<span class="sd">        ``User.addresses`` to *adapt* itself to the altered target::</span>

<span class="sd">            address_subq = session.query(Address).\</span>
<span class="sd">                            filter(Address.email_address == 'ed@foo.com').\</span>
<span class="sd">                            subquery()</span>

<span class="sd">            q = session.query(User).join(address_subq, User.addresses)</span>

<span class="sd">        Producing SQL similar to::</span>

<span class="sd">            SELECT user.* FROM user</span>
<span class="sd">                JOIN (</span>
<span class="sd">                    SELECT address.id AS id,</span>
<span class="sd">                            address.user_id AS user_id,</span>
<span class="sd">                            address.email_address AS email_address</span>
<span class="sd">                    FROM address</span>
<span class="sd">                    WHERE address.email_address = :email_address_1</span>
<span class="sd">                ) AS anon_1 ON user.id = anon_1.user_id</span>

<span class="sd">        The above form allows one to fall back onto an explicit ON</span>
<span class="sd">        clause at any time::</span>

<span class="sd">            q = session.query(User).\</span>
<span class="sd">                    join(address_subq, User.id==address_subq.c.user_id)</span>

<span class="sd">        **Controlling what to Join From**</span>

<span class="sd">        While :meth:`~.Query.join` exclusively deals with the "right"</span>
<span class="sd">        side of the JOIN, we can also control the "left" side, in those</span>
<span class="sd">        cases where it's needed, using :meth:`~.Query.select_from`.</span>
<span class="sd">        Below we construct a query against ``Address`` but can still</span>
<span class="sd">        make usage of ``User.addresses`` as our ON clause by instructing</span>
<span class="sd">        the :class:`.Query` to select first from the ``User``</span>
<span class="sd">        entity::</span>

<span class="sd">            q = session.query(Address).select_from(User).\</span>
<span class="sd">                            join(User.addresses).\</span>
<span class="sd">                            filter(User.name == 'ed')</span>

<span class="sd">        Which will produce SQL similar to::</span>

<span class="sd">            SELECT address.* FROM user</span>
<span class="sd">                JOIN address ON user.id=address.user_id</span>
<span class="sd">                WHERE user.name = :name_1</span>

<span class="sd">        **Constructing Aliases Anonymously**</span>

<span class="sd">        :meth:`~.Query.join` can construct anonymous aliases</span>
<span class="sd">        using the ``aliased=True`` flag.  This feature is useful</span>
<span class="sd">        when a query is being joined algorithmically, such as</span>
<span class="sd">        when querying self-referentially to an arbitrary depth::</span>

<span class="sd">            q = session.query(Node).\</span>
<span class="sd">                    join("children", "children", aliased=True)</span>

<span class="sd">        When ``aliased=True`` is used, the actual "alias" construct</span>
<span class="sd">        is not explicitly available.  To work with it, methods such as</span>
<span class="sd">        :meth:`.Query.filter` will adapt the incoming entity to</span>
<span class="sd">        the last join point::</span>

<span class="sd">            q = session.query(Node).\</span>
<span class="sd">                    join("children", "children", aliased=True).\</span>
<span class="sd">                    filter(Node.name == 'grandchild 1')</span>

<span class="sd">        When using automatic aliasing, the ``from_joinpoint=True``</span>
<span class="sd">        argument can allow a multi-node join to be broken into</span>
<span class="sd">        multiple calls to :meth:`~.Query.join`, so that</span>
<span class="sd">        each path along the way can be further filtered::</span>

<span class="sd">            q = session.query(Node).\</span>
<span class="sd">                    join("children", aliased=True).\</span>
<span class="sd">                    filter(Node.name='child 1').\</span>
<span class="sd">                    join("children", aliased=True, from_joinpoint=True).\</span>
<span class="sd">                    filter(Node.name == 'grandchild 1')</span>

<span class="sd">        The filtering aliases above can then be reset back to the</span>
<span class="sd">        original ``Node`` entity using :meth:`~.Query.reset_joinpoint`::</span>

<span class="sd">            q = session.query(Node).\</span>
<span class="sd">                    join("children", "children", aliased=True).\</span>
<span class="sd">                    filter(Node.name == 'grandchild 1').\</span>
<span class="sd">                    reset_joinpoint().\</span>
<span class="sd">                    filter(Node.name == 'parent 1)</span>

<span class="sd">        For an example of ``aliased=True``, see the distribution</span>
<span class="sd">        example :ref:`examples_xmlpersistence` which illustrates</span>
<span class="sd">        an XPath-like query system using algorithmic joins.</span>

<span class="sd">        :param \*props: A collection of one or more join conditions,</span>
<span class="sd">         each consisting of a relationship-bound attribute or string</span>
<span class="sd">         relationship name representing an "on clause", or a single</span>
<span class="sd">         target entity, or a tuple in the form of ``(target, onclause)``.</span>
<span class="sd">         A special two-argument calling form of the form ``target, onclause``</span>
<span class="sd">         is also accepted.</span>
<span class="sd">        :param aliased=False: If True, indicate that the JOIN target should be</span>
<span class="sd">         anonymously aliased.  Subsequent calls to :meth:`~.Query.filter`</span>
<span class="sd">         and similar will adapt the incoming criterion to the target</span>
<span class="sd">         alias, until :meth:`~.Query.reset_joinpoint` is called.</span>
<span class="sd">        :param isouter=False: If True, the join used will be a left outer join,</span>
<span class="sd">         just as if the :meth:`.Query.outerjoin` method were called.  This</span>
<span class="sd">         flag is here to maintain consistency with the same flag as accepted</span>
<span class="sd">         by :meth:`.FromClause.join` and other Core constructs.</span>


<span class="sd">         .. versionadded:: 1.0.0</span>

<span class="sd">        :param full=False: render FULL OUTER JOIN; implies ``isouter``.</span>

<span class="sd">         .. versionadded:: 1.1</span>

<span class="sd">        :param from_joinpoint=False: When using ``aliased=True``, a setting</span>
<span class="sd">         of True here will cause the join to be from the most recent</span>
<span class="sd">         joined target, rather than starting back from the original</span>
<span class="sd">         FROM clauses of the query.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`ormtutorial_joins` in the ORM tutorial.</span>

<span class="sd">            :ref:`inheritance_toplevel` for details on how</span>
<span class="sd">            :meth:`~.Query.join` is used for inheritance relationships.</span>

<span class="sd">            :func:`.orm.join` - a standalone ORM-level join function,</span>
<span class="sd">            used internally by :meth:`.Query.join`, which in previous</span>
<span class="sd">            SQLAlchemy versions was the primary ORM-level joining interface.</span>

<span class="sd">        """</span>
        <span class="n">aliased</span><span class="p">,</span> <span class="n">from_joinpoint</span><span class="p">,</span> <span class="n">isouter</span><span class="p">,</span> <span class="n">full</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"aliased"</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"from_joinpoint"</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"isouter"</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"full"</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">"unknown arguments: </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="s2">", "</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join</span><span class="p">(</span>
            <span class="n">props</span><span class="p">,</span>
            <span class="n">outerjoin</span><span class="o">=</span><span class="n">isouter</span><span class="p">,</span>
            <span class="n">full</span><span class="o">=</span><span class="n">full</span><span class="p">,</span>
            <span class="n">create_aliases</span><span class="o">=</span><span class="n">aliased</span><span class="p">,</span>
            <span class="n">from_joinpoint</span><span class="o">=</span><span class="n">from_joinpoint</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">outerjoin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">props</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Create a left outer join against this ``Query`` object's criterion</span>
<span class="sd">        and apply generatively, returning the newly resulting ``Query``.</span>

<span class="sd">        Usage is the same as the ``join()`` method.</span>

<span class="sd">        """</span>
        <span class="n">aliased</span><span class="p">,</span> <span class="n">from_joinpoint</span><span class="p">,</span> <span class="n">full</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"aliased"</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"from_joinpoint"</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"full"</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">"unknown arguments: </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="s2">", "</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join</span><span class="p">(</span>
            <span class="n">props</span><span class="p">,</span>
            <span class="n">outerjoin</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">full</span><span class="o">=</span><span class="n">full</span><span class="p">,</span>
            <span class="n">create_aliases</span><span class="o">=</span><span class="n">aliased</span><span class="p">,</span>
            <span class="n">from_joinpoint</span><span class="o">=</span><span class="n">from_joinpoint</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_joinpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jp</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_joinpoint</span> <span class="o">=</span> <span class="n">jp</span>
        <span class="c1"># copy backwards to the root of the _joinpath</span>
        <span class="c1"># dict, so that no existing dict in the path is mutated</span>
        <span class="k">while</span> <span class="s2">"prev"</span> <span class="ow">in</span> <span class="n">jp</span><span class="p">:</span>
            <span class="n">f</span><span class="p">,</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">jp</span><span class="p">[</span><span class="s2">"prev"</span><span class="p">]</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">prev</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">jp</span>
            <span class="n">jp</span><span class="p">[</span><span class="s2">"prev"</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">prev</span><span class="p">)</span>
            <span class="n">jp</span> <span class="o">=</span> <span class="n">prev</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_joinpath</span> <span class="o">=</span> <span class="n">jp</span>

    <span class="nd">@_generative</span><span class="p">(</span><span class="n">_no_statement_condition</span><span class="p">,</span> <span class="n">_no_limit_offset</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">outerjoin</span><span class="p">,</span> <span class="n">full</span><span class="p">,</span> <span class="n">create_aliases</span><span class="p">,</span> <span class="n">from_joinpoint</span><span class="p">):</span>
        <span class="sd">"""consumes arguments from join() or outerjoin(), places them into a</span>
<span class="sd">        consistent format with which to form the actual JOIN constructs.</span>

<span class="sd">        """</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">from_joinpoint</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reset_joinpoint</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">expression</span><span class="o">.</span><span class="n">FromClause</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">AliasedClass</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">keys</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">expression</span><span class="o">.</span><span class="n">ClauseElement</span><span class="p">,</span> <span class="n">interfaces</span><span class="o">.</span><span class="n">PropComparator</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># detect 2-arg form of join and</span>
            <span class="c1"># convert to a tuple.</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="p">(</span><span class="n">keys</span><span class="p">,)</span>

        <span class="c1"># Query.join() accepts a list of join paths all at once.</span>
        <span class="c1"># step one is to iterate through these paths and determine the</span>
        <span class="c1"># intent of each path individually.  as we encounter a path token,</span>
        <span class="c1"># we add a new ORMJoin construct to the self._from_obj tuple,</span>
        <span class="c1"># either by adding a new element to it, or by replacing an existing</span>
        <span class="c1"># element with a new ORMJoin.</span>
        <span class="n">keylist</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">arg1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">keylist</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="c1"># "tuple" form of join, multiple</span>
                <span class="c1"># tuples are accepted as well.   The simpler</span>
                <span class="c1"># "2-arg" form is preferred.</span>
                <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span> <span class="o">=</span> <span class="n">arg1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">arg2</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># determine onclause/right_entity.  there</span>
            <span class="c1"># is a little bit of legacy behavior still at work here</span>
            <span class="c1"># which means they might be in either order.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">arg1</span><span class="p">,</span> <span class="p">(</span><span class="n">interfaces</span><span class="o">.</span><span class="n">PropComparator</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">string_types</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">right</span><span class="p">,</span> <span class="n">onclause</span> <span class="o">=</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">right</span><span class="p">,</span> <span class="n">onclause</span> <span class="o">=</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span>

            <span class="k">if</span> <span class="n">onclause</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">r_info</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">r_info</span><span class="o">.</span><span class="n">is_selectable</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">r_info</span><span class="p">,</span> <span class="s2">"mapper"</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                        <span class="s2">"Expected mapped entity or "</span>
                        <span class="s2">"selectable/table as join target"</span>
                    <span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">onclause</span><span class="p">,</span> <span class="n">interfaces</span><span class="o">.</span><span class="n">PropComparator</span><span class="p">):</span>
                <span class="n">of_type</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">onclause</span><span class="p">,</span> <span class="s2">"_of_type"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">of_type</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">onclause</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
                <span class="c1"># string given, e.g. query(Foo).join("bar").</span>
                <span class="c1"># we look to the left entity or what we last joined</span>
                <span class="c1"># towards</span>
                <span class="n">onclause</span> <span class="o">=</span> <span class="n">_entity_descriptor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_joinpoint_zero</span><span class="p">(),</span> <span class="n">onclause</span><span class="p">)</span>

            <span class="c1"># check for q.join(Class.propname, from_joinpoint=True)</span>
            <span class="c1"># and Class corresponds at the mapper level to the current</span>
            <span class="c1"># joinpoint.  this match intentionally looks for a non-aliased</span>
            <span class="c1"># class-bound descriptor as the onclause and if it matches the</span>
            <span class="c1"># current joinpoint at the mapper level, it's used.  This</span>
            <span class="c1"># is a very old use case that is intended to make it easier</span>
            <span class="c1"># to work with the aliased=True flag, which is also something</span>
            <span class="c1"># that probably shouldn't exist on join() due to its high</span>
            <span class="c1"># complexity/usefulness ratio</span>
            <span class="k">elif</span> <span class="n">from_joinpoint</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">onclause</span><span class="p">,</span> <span class="n">interfaces</span><span class="o">.</span><span class="n">PropComparator</span>
            <span class="p">):</span>
                <span class="n">jp0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_joinpoint_zero</span><span class="p">()</span>
                <span class="n">info</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">jp0</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s2">"mapper"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="n">onclause</span><span class="o">.</span><span class="n">_parententity</span><span class="p">:</span>
                    <span class="n">onclause</span> <span class="o">=</span> <span class="n">_entity_descriptor</span><span class="p">(</span><span class="n">jp0</span><span class="p">,</span> <span class="n">onclause</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">onclause</span><span class="p">,</span> <span class="n">interfaces</span><span class="o">.</span><span class="n">PropComparator</span><span class="p">):</span>
                <span class="c1"># descriptor/property given (or determined); this tells</span>
                <span class="c1"># us explicitly what the expected "left" side of the join is.</span>
                <span class="k">if</span> <span class="n">right</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">of_type</span><span class="p">:</span>
                        <span class="n">right</span> <span class="o">=</span> <span class="n">of_type</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">right</span> <span class="o">=</span> <span class="n">onclause</span><span class="o">.</span><span class="n">property</span><span class="o">.</span><span class="n">entity</span>

                <span class="n">left</span> <span class="o">=</span> <span class="n">onclause</span><span class="o">.</span><span class="n">_parententity</span>

                <span class="n">alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polymorphic_adapters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

                <span class="c1"># could be None or could be ColumnAdapter also</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">ORMAdapter</span><span class="p">)</span> <span class="ow">and</span> <span class="n">alias</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">isa</span><span class="p">(</span><span class="n">left</span><span class="p">):</span>
                    <span class="n">left</span> <span class="o">=</span> <span class="n">alias</span><span class="o">.</span><span class="n">aliased_class</span>
                    <span class="n">onclause</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">onclause</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>

                <span class="n">prop</span> <span class="o">=</span> <span class="n">onclause</span><span class="o">.</span><span class="n">property</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">onclause</span><span class="p">,</span> <span class="n">attributes</span><span class="o">.</span><span class="n">QueryableAttribute</span><span class="p">):</span>
                    <span class="n">onclause</span> <span class="o">=</span> <span class="n">prop</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">create_aliases</span><span class="p">:</span>
                    <span class="c1"># check for this path already present.</span>
                    <span class="c1"># don't render in that case.</span>
                    <span class="n">edge</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">prop</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_joinpoint</span><span class="p">:</span>
                        <span class="c1"># The child's prev reference might be stale --</span>
                        <span class="c1"># it could point to a parent older than the</span>
                        <span class="c1"># current joinpoint.  If this is the case,</span>
                        <span class="c1"># then we need to update it and then fix the</span>
                        <span class="c1"># tree's spine with _update_joinpoint.  Copy</span>
                        <span class="c1"># and then mutate the child, which might be</span>
                        <span class="c1"># shared by a different query object.</span>
                        <span class="n">jp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_joinpoint</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="n">jp</span><span class="p">[</span><span class="s2">"prev"</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_joinpoint</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_update_joinpoint</span><span class="p">(</span><span class="n">jp</span><span class="p">)</span>

                        <span class="c1"># warn only on the last element of the list</span>
                        <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">keylist</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">util</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                                <span class="s2">"Pathed join target </span><span class="si">%s</span><span class="s2"> has already "</span>
                                <span class="s2">"been joined to; skipping"</span> <span class="o">%</span> <span class="n">prop</span>
                            <span class="p">)</span>
                        <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># no descriptor/property given; we will need to figure out</span>
                <span class="c1"># what the effective "left" side is</span>
                <span class="n">prop</span> <span class="o">=</span> <span class="n">left</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># figure out the final "left" and "right" sides and create an</span>
            <span class="c1"># ORMJoin to add to our _from_obj tuple</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_join_left_to_right</span><span class="p">(</span>
                <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">onclause</span><span class="p">,</span> <span class="n">prop</span><span class="p">,</span> <span class="n">create_aliases</span><span class="p">,</span> <span class="n">outerjoin</span><span class="p">,</span> <span class="n">full</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_join_left_to_right</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">onclause</span><span class="p">,</span> <span class="n">prop</span><span class="p">,</span> <span class="n">create_aliases</span><span class="p">,</span> <span class="n">outerjoin</span><span class="p">,</span> <span class="n">full</span>
    <span class="p">):</span>
        <span class="sd">"""given raw "left", "right", "onclause" parameters consumed from</span>
<span class="sd">        a particular key within _join(), add a real ORMJoin object to</span>
<span class="sd">        our _from_obj list (or augment an existing one)</span>

<span class="sd">        """</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_polymorphic_adapters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polymorphic_adapters</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">left</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># left not given (e.g. no relationship object/name specified)</span>
            <span class="c1"># figure out the best "left" side based on our existing froms /</span>
            <span class="c1"># entities</span>
            <span class="k">assert</span> <span class="n">prop</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="p">(</span>
                <span class="n">left</span><span class="p">,</span>
                <span class="n">replace_from_obj_index</span><span class="p">,</span>
                <span class="n">use_entity_index</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_determine_implicit_left_side</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">onclause</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># left is given via a relationship/name.  Determine where in our</span>
            <span class="c1"># "froms" list it should be spliced/appended as well as what</span>
            <span class="c1"># existing entity it corresponds to.</span>
            <span class="k">assert</span> <span class="n">prop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">(</span>
                <span class="n">replace_from_obj_index</span><span class="p">,</span>
                <span class="n">use_entity_index</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_place_explicit_left_side</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">left</span> <span class="ow">is</span> <span class="n">right</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">create_aliases</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">"Can't construct a join from </span><span class="si">%s</span><span class="s2"> to </span><span class="si">%s</span><span class="s2">, they "</span>
                <span class="s2">"are the same entity"</span> <span class="o">%</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># the right side as given often needs to be adapted.  additionally</span>
        <span class="c1"># a lot of things can be wrong with it.  handle all that and</span>
        <span class="c1"># get back the new effective "right" side</span>
        <span class="n">r_info</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">onclause</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_check_and_adapt_right_side</span><span class="p">(</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">onclause</span><span class="p">,</span> <span class="n">prop</span><span class="p">,</span> <span class="n">create_aliases</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">replace_from_obj_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># splice into an existing element in the</span>
            <span class="c1"># self._from_obj list</span>
            <span class="n">left_clause</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span><span class="p">[</span><span class="n">replace_from_obj_index</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span><span class="p">[:</span><span class="n">replace_from_obj_index</span><span class="p">]</span>
                <span class="o">+</span> <span class="p">(</span>
                    <span class="n">orm_join</span><span class="p">(</span>
                        <span class="n">left_clause</span><span class="p">,</span>
                        <span class="n">right</span><span class="p">,</span>
                        <span class="n">onclause</span><span class="p">,</span>
                        <span class="n">isouter</span><span class="o">=</span><span class="n">outerjoin</span><span class="p">,</span>
                        <span class="n">full</span><span class="o">=</span><span class="n">full</span><span class="p">,</span>
                    <span class="p">),</span>
                <span class="p">)</span>
                <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span><span class="p">[</span><span class="n">replace_from_obj_index</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># add a new element to the self._from_obj list</span>

            <span class="k">if</span> <span class="n">use_entity_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># why doesn't this work as .entity_zero_or_selectable?</span>
                <span class="n">left_clause</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">[</span><span class="n">use_entity_index</span><span class="p">]</span><span class="o">.</span><span class="n">selectable</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">left_clause</span> <span class="o">=</span> <span class="n">left</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span> <span class="o">+</span> <span class="p">(</span>
                <span class="n">orm_join</span><span class="p">(</span>
                    <span class="n">left_clause</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">onclause</span><span class="p">,</span> <span class="n">isouter</span><span class="o">=</span><span class="n">outerjoin</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="n">full</span>
                <span class="p">),</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_join_determine_implicit_left_side</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">onclause</span><span class="p">):</span>
        <span class="sd">"""When join conditions don't express the left side explicitly,</span>
<span class="sd">        determine if an existing FROM or entity in this query</span>
<span class="sd">        can serve as the left hand side.</span>

<span class="sd">        """</span>

        <span class="c1"># when we are here, it means join() was called without an ORM-</span>
        <span class="c1"># specific way of telling us what the "left" side is, e.g.:</span>
        <span class="c1">#</span>
        <span class="c1"># join(RightEntity)</span>
        <span class="c1">#</span>
        <span class="c1"># or</span>
        <span class="c1">#</span>
        <span class="c1"># join(RightEntity, RightEntity.foo == LeftEntity.bar)</span>
        <span class="c1">#</span>

        <span class="n">r_info</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

        <span class="n">replace_from_obj_index</span> <span class="o">=</span> <span class="n">use_entity_index</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span><span class="p">:</span>
            <span class="c1"># we have a list of FROMs already.  So by definition this</span>
            <span class="c1"># join has to connect to one of those FROMs.</span>

            <span class="n">indexes</span> <span class="o">=</span> <span class="n">sql_util</span><span class="o">.</span><span class="n">find_left_clause_to_join_from</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span><span class="p">,</span> <span class="n">r_info</span><span class="o">.</span><span class="n">selectable</span><span class="p">,</span> <span class="n">onclause</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">replace_from_obj_index</span> <span class="o">=</span> <span class="n">indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span><span class="p">[</span><span class="n">replace_from_obj_index</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s2">"Can't determine which FROM clause to join "</span>
                    <span class="s2">"from, there are multiple FROMS which can "</span>
                    <span class="s2">"join to this entity. Try adding an explicit ON clause "</span>
                    <span class="s2">"to help resolve the ambiguity."</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s2">"Don't know how to join to </span><span class="si">%s</span><span class="s2">; please use "</span>
                    <span class="s2">"an ON clause to more clearly establish the left "</span>
                    <span class="s2">"side of this join"</span> <span class="o">%</span> <span class="p">(</span><span class="n">right</span><span class="p">,)</span>
                <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">:</span>
            <span class="c1"># we have no explicit FROMs, so the implicit left has to</span>
            <span class="c1"># come from our list of entities.</span>

            <span class="n">potential</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">entity_index</span><span class="p">,</span> <span class="n">ent</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">):</span>
                <span class="n">entity</span> <span class="o">=</span> <span class="n">ent</span><span class="o">.</span><span class="n">entity_zero_or_selectable</span>
                <span class="k">if</span> <span class="n">entity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">ent_info</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">entity</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ent_info</span> <span class="ow">is</span> <span class="n">r_info</span><span class="p">:</span>  <span class="c1"># left and right are the same, skip</span>
                    <span class="k">continue</span>

                <span class="c1"># by using a dictionary with the selectables as keys this</span>
                <span class="c1"># de-duplicates those selectables as occurs when the query is</span>
                <span class="c1"># against a series of columns from the same selectable</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ent</span><span class="p">,</span> <span class="n">_MapperEntity</span><span class="p">):</span>
                    <span class="n">potential</span><span class="p">[</span><span class="n">ent</span><span class="o">.</span><span class="n">selectable</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">entity_index</span><span class="p">,</span> <span class="n">entity</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">potential</span><span class="p">[</span><span class="n">ent_info</span><span class="o">.</span><span class="n">selectable</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">entity</span><span class="p">)</span>

            <span class="n">all_clauses</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">potential</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="n">sql_util</span><span class="o">.</span><span class="n">find_left_clause_to_join_from</span><span class="p">(</span>
                <span class="n">all_clauses</span><span class="p">,</span> <span class="n">r_info</span><span class="o">.</span><span class="n">selectable</span><span class="p">,</span> <span class="n">onclause</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">use_entity_index</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="n">potential</span><span class="p">[</span><span class="n">all_clauses</span><span class="p">[</span><span class="n">indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s2">"Can't determine which FROM clause to join "</span>
                    <span class="s2">"from, there are multiple FROMS which can "</span>
                    <span class="s2">"join to this entity. Try adding an explicit ON clause "</span>
                    <span class="s2">"to help resolve the ambiguity."</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s2">"Don't know how to join to </span><span class="si">%s</span><span class="s2">; please use "</span>
                    <span class="s2">"an ON clause to more clearly establish the left "</span>
                    <span class="s2">"side of this join"</span> <span class="o">%</span> <span class="p">(</span><span class="n">right</span><span class="p">,)</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">"No entities to join from; please use "</span>
                <span class="s2">"select_from() to establish the left "</span>
                <span class="s2">"entity/selectable of this join"</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">left</span><span class="p">,</span> <span class="n">replace_from_obj_index</span><span class="p">,</span> <span class="n">use_entity_index</span>

    <span class="k">def</span> <span class="nf">_join_place_explicit_left_side</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">):</span>
        <span class="sd">"""When join conditions express a left side explicitly, determine</span>
<span class="sd">        where in our existing list of FROM clauses we should join towards,</span>
<span class="sd">        or if we need to make a new join, and if so is it from one of our</span>
<span class="sd">        existing entities.</span>

<span class="sd">        """</span>

        <span class="c1"># when we are here, it means join() was called with an indicator</span>
        <span class="c1"># as to an exact left side, which means a path to a</span>
        <span class="c1"># RelationshipProperty was given, e.g.:</span>
        <span class="c1">#</span>
        <span class="c1"># join(RightEntity, LeftEntity.right)</span>
        <span class="c1">#</span>
        <span class="c1"># or</span>
        <span class="c1">#</span>
        <span class="c1"># join(LeftEntity.right)</span>
        <span class="c1">#</span>
        <span class="c1"># as well as string forms:</span>
        <span class="c1">#</span>
        <span class="c1"># join(RightEntity, "right")</span>
        <span class="c1">#</span>
        <span class="c1"># etc.</span>
        <span class="c1">#</span>

        <span class="n">replace_from_obj_index</span> <span class="o">=</span> <span class="n">use_entity_index</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">l_info</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span><span class="p">:</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="n">sql_util</span><span class="o">.</span><span class="n">find_left_clause_that_matches_given</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span><span class="p">,</span> <span class="n">l_info</span><span class="o">.</span><span class="n">selectable</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s2">"Can't identify which entity in which to assign the "</span>
                    <span class="s2">"left side of this join.   Please use a more specific "</span>
                    <span class="s2">"ON clause."</span>
                <span class="p">)</span>

            <span class="c1"># have an index, means the left side is already present in</span>
            <span class="c1"># an existing FROM in the self._from_obj tuple</span>
            <span class="k">if</span> <span class="n">indexes</span><span class="p">:</span>
                <span class="n">replace_from_obj_index</span> <span class="o">=</span> <span class="n">indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># no index, means we need to add a new element to the</span>
            <span class="c1"># self._from_obj tuple</span>

        <span class="c1"># no from element present, so we will have to add to the</span>
        <span class="c1"># self._from_obj tuple.  Determine if this left side matches up</span>
        <span class="c1"># with existing mapper entities, in which case we want to apply the</span>
        <span class="c1"># aliasing / adaptation rules present on that entity if any</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">replace_from_obj_index</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span>
            <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">l_info</span><span class="p">,</span> <span class="s2">"mapper"</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">ent</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">):</span>
                <span class="c1"># TODO: should we be checking for multiple mapper entities</span>
                <span class="c1"># matching?</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ent</span><span class="p">,</span> <span class="n">_MapperEntity</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ent</span><span class="o">.</span><span class="n">corresponds_to</span><span class="p">(</span><span class="n">left</span><span class="p">):</span>
                    <span class="n">use_entity_index</span> <span class="o">=</span> <span class="n">idx</span>
                    <span class="k">break</span>

        <span class="k">return</span> <span class="n">replace_from_obj_index</span><span class="p">,</span> <span class="n">use_entity_index</span>

    <span class="k">def</span> <span class="nf">_join_check_and_adapt_right_side</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">onclause</span><span class="p">,</span> <span class="n">prop</span><span class="p">,</span> <span class="n">create_aliases</span>
    <span class="p">):</span>
        <span class="sd">"""transform the "right" side of the join as well as the onclause</span>
<span class="sd">        according to polymorphic mapping translations, aliasing on the query</span>
<span class="sd">        or on the join, special cases where the right and left side have</span>
<span class="sd">        overlapping tables.</span>

<span class="sd">        """</span>

        <span class="n">l_info</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
        <span class="n">r_info</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

        <span class="n">overlap</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">create_aliases</span><span class="p">:</span>
            <span class="n">right_mapper</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">r_info</span><span class="p">,</span> <span class="s2">"mapper"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="c1"># if the target is a joined inheritance mapping,</span>
            <span class="c1"># be more liberal about auto-aliasing.</span>
            <span class="k">if</span> <span class="n">right_mapper</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">right_mapper</span><span class="o">.</span><span class="n">with_polymorphic</span>
                <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right_mapper</span><span class="o">.</span><span class="n">persist_selectable</span><span class="p">,</span> <span class="n">expression</span><span class="o">.</span><span class="n">Join</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">for</span> <span class="n">from_obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span> <span class="ow">or</span> <span class="p">[</span><span class="n">l_info</span><span class="o">.</span><span class="n">selectable</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">sql_util</span><span class="o">.</span><span class="n">selectables_overlap</span><span class="p">(</span>
                        <span class="n">l_info</span><span class="o">.</span><span class="n">selectable</span><span class="p">,</span> <span class="n">from_obj</span>
                    <span class="p">)</span> <span class="ow">and</span> <span class="n">sql_util</span><span class="o">.</span><span class="n">selectables_overlap</span><span class="p">(</span>
                        <span class="n">from_obj</span><span class="p">,</span> <span class="n">r_info</span><span class="o">.</span><span class="n">selectable</span>
                    <span class="p">):</span>
                        <span class="n">overlap</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">overlap</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">create_aliases</span>
        <span class="p">)</span> <span class="ow">and</span> <span class="n">l_info</span><span class="o">.</span><span class="n">selectable</span> <span class="ow">is</span> <span class="n">r_info</span><span class="o">.</span><span class="n">selectable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">"Can't join table/selectable '</span><span class="si">%s</span><span class="s2">' to itself"</span>
                <span class="o">%</span> <span class="n">l_info</span><span class="o">.</span><span class="n">selectable</span>
            <span class="p">)</span>

        <span class="n">right_mapper</span><span class="p">,</span> <span class="n">right_selectable</span><span class="p">,</span> <span class="n">right_is_aliased</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="n">r_info</span><span class="p">,</span> <span class="s2">"mapper"</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="n">r_info</span><span class="o">.</span><span class="n">selectable</span><span class="p">,</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="n">r_info</span><span class="p">,</span> <span class="s2">"is_aliased_class"</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">right_mapper</span>
            <span class="ow">and</span> <span class="n">prop</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="n">right_mapper</span><span class="o">.</span><span class="n">common_parent</span><span class="p">(</span><span class="n">prop</span><span class="o">.</span><span class="n">mapper</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">"Join target </span><span class="si">%s</span><span class="s2"> does not correspond to "</span>
                <span class="s2">"the right side of join condition </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">onclause</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># _join_entities is used as a hint for single-table inheritance</span>
        <span class="c1"># purposes at the moment</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">r_info</span><span class="p">,</span> <span class="s2">"mapper"</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_join_entities</span> <span class="o">+=</span> <span class="p">(</span><span class="n">r_info</span><span class="p">,)</span>

        <span class="n">need_adapter</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># test for joining to an unmapped selectable as the target</span>
        <span class="k">if</span> <span class="n">r_info</span><span class="o">.</span><span class="n">is_clause_element</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">prop</span><span class="p">:</span>
                <span class="n">right_mapper</span> <span class="o">=</span> <span class="n">prop</span><span class="o">.</span><span class="n">mapper</span>

            <span class="k">if</span> <span class="n">right_selectable</span><span class="o">.</span><span class="n">_is_lateral</span><span class="p">:</span>
                <span class="c1"># orm_only is disabled to suit the case where we have to</span>
                <span class="c1"># adapt an explicit correlate(Entity) - the select() loses</span>
                <span class="c1"># the ORM-ness in this case right now, ideally it would not</span>
                <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_clause</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">prop</span><span class="p">:</span>
                <span class="c1"># joining to selectable with a mapper property given</span>
                <span class="c1"># as the ON clause</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">right_selectable</span><span class="o">.</span><span class="n">is_derived_from</span><span class="p">(</span>
                    <span class="n">right_mapper</span><span class="o">.</span><span class="n">persist_selectable</span>
                <span class="p">):</span>
                    <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                        <span class="s2">"Selectable '</span><span class="si">%s</span><span class="s2">' is not derived from '</span><span class="si">%s</span><span class="s2">'"</span>
                        <span class="o">%</span> <span class="p">(</span>
                            <span class="n">right_selectable</span><span class="o">.</span><span class="n">description</span><span class="p">,</span>
                            <span class="n">right_mapper</span><span class="o">.</span><span class="n">persist_selectable</span><span class="o">.</span><span class="n">description</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

                <span class="c1"># if the destination selectable is a plain select(),</span>
                <span class="c1"># turn it into an alias().</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right_selectable</span><span class="p">,</span> <span class="n">expression</span><span class="o">.</span><span class="n">SelectBase</span><span class="p">):</span>
                    <span class="n">right_selectable</span> <span class="o">=</span> <span class="n">right_selectable</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span>
                    <span class="n">need_adapter</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># make the right hand side target into an ORM entity</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">right_mapper</span><span class="p">,</span> <span class="n">right_selectable</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">create_aliases</span><span class="p">:</span>
                <span class="c1"># it *could* work, but it doesn't right now and I'd rather</span>
                <span class="c1"># get rid of aliased=True completely</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s2">"The aliased=True parameter on query.join() only works "</span>
                    <span class="s2">"with an ORM entity, not a plain selectable, as the "</span>
                    <span class="s2">"target."</span>
                <span class="p">)</span>

        <span class="n">aliased_entity</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">right_mapper</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="n">right_is_aliased</span>
            <span class="ow">and</span> <span class="p">(</span>
                <span class="n">right_mapper</span><span class="o">.</span><span class="n">with_polymorphic</span>
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
                    <span class="n">right_mapper</span><span class="o">.</span><span class="n">_with_polymorphic_selectable</span><span class="p">,</span> <span class="n">expression</span><span class="o">.</span><span class="n">Alias</span>
                <span class="p">)</span>
                <span class="ow">or</span> <span class="n">overlap</span>
                <span class="c1"># test for overlap:</span>
                <span class="c1"># orm/inheritance/relationships.py</span>
                <span class="c1"># SelfReferentialM2MTest</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">need_adapter</span> <span class="ow">and</span> <span class="p">(</span><span class="n">create_aliases</span> <span class="ow">or</span> <span class="n">aliased_entity</span><span class="p">):</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">need_adapter</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">need_adapter</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">right_mapper</span>

            <span class="c1"># if an alias() of the right side was generated,</span>
            <span class="c1"># apply an adapter to all subsequent filter() calls</span>
            <span class="c1"># until reset_joinpoint() is called.</span>
            <span class="n">adapter</span> <span class="o">=</span> <span class="n">ORMAdapter</span><span class="p">(</span>
                <span class="n">right</span><span class="p">,</span> <span class="n">equivalents</span><span class="o">=</span><span class="n">right_mapper</span><span class="o">.</span><span class="n">_equivalent_columns</span>
            <span class="p">)</span>
            <span class="c1"># current adapter takes highest precedence</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_filter_aliases</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter</span><span class="p">,)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_aliases</span>

            <span class="c1"># if an alias() on the right side was generated,</span>
            <span class="c1"># which is intended to wrap a the right side in a subquery,</span>
            <span class="c1"># ensure that columns retrieved from this target in the result</span>
            <span class="c1"># set are also adapted.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">create_aliases</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mapper_loads_polymorphically_with</span><span class="p">(</span><span class="n">right_mapper</span><span class="p">,</span> <span class="n">adapter</span><span class="p">)</span>

        <span class="c1"># if the onclause is a ClauseElement, adapt it with any</span>
        <span class="c1"># adapters that are in place right now</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">onclause</span><span class="p">,</span> <span class="n">expression</span><span class="o">.</span><span class="n">ClauseElement</span><span class="p">):</span>
            <span class="n">onclause</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_clause</span><span class="p">(</span><span class="n">onclause</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># if joining on a MapperProperty path,</span>
        <span class="c1"># track the path to prevent redundant joins</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">create_aliases</span> <span class="ow">and</span> <span class="n">prop</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_joinpoint</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">"_joinpoint_entity"</span><span class="p">:</span> <span class="n">right</span><span class="p">,</span>
                    <span class="s2">"prev"</span><span class="p">:</span> <span class="p">((</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">prop</span><span class="o">.</span><span class="n">key</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_joinpoint</span><span class="p">),</span>
                <span class="p">}</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_joinpoint</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"_joinpoint_entity"</span><span class="p">:</span> <span class="n">right</span><span class="p">}</span>

        <span class="k">return</span> <span class="n">right</span><span class="p">,</span> <span class="n">inspect</span><span class="p">(</span><span class="n">right</span><span class="p">),</span> <span class="n">onclause</span>

    <span class="k">def</span> <span class="nf">_reset_joinpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_joinpoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_joinpath</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filter_aliases</span> <span class="o">=</span> <span class="p">()</span>

    <span class="nd">@_generative</span><span class="p">(</span><span class="n">_no_statement_condition</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">reset_joinpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Return a new :class:`.Query`, where the "join point" has</span>
<span class="sd">        been reset back to the base FROM entities of the query.</span>

<span class="sd">        This method is usually used in conjunction with the</span>
<span class="sd">        ``aliased=True`` feature of the :meth:`~.Query.join`</span>
<span class="sd">        method.  See the example in :meth:`~.Query.join` for how</span>
<span class="sd">        this is used.</span>

<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_joinpoint</span><span class="p">()</span>

    <span class="nd">@_generative</span><span class="p">(</span><span class="n">_no_clauseelement_condition</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">select_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">from_obj</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Set the FROM clause of this :class:`.Query` explicitly.</span>

<span class="sd">        :meth:`.Query.select_from` is often used in conjunction with</span>
<span class="sd">        :meth:`.Query.join` in order to control which entity is selected</span>
<span class="sd">        from on the "left" side of the join.</span>

<span class="sd">        The entity or selectable object here effectively replaces the</span>
<span class="sd">        "left edge" of any calls to :meth:`~.Query.join`, when no</span>
<span class="sd">        joinpoint is otherwise established - usually, the default "join</span>
<span class="sd">        point" is the leftmost entity in the :class:`~.Query` object's</span>
<span class="sd">        list of entities to be selected.</span>

<span class="sd">        A typical example::</span>

<span class="sd">            q = session.query(Address).select_from(User).\</span>
<span class="sd">                join(User.addresses).\</span>
<span class="sd">                filter(User.name == 'ed')</span>

<span class="sd">        Which produces SQL equivalent to::</span>

<span class="sd">            SELECT address.* FROM user</span>
<span class="sd">            JOIN address ON user.id=address.user_id</span>
<span class="sd">            WHERE user.name = :name_1</span>

<span class="sd">        :param \*from_obj: collection of one or more entities to apply</span>
<span class="sd">         to the FROM clause.  Entities can be mapped classes,</span>
<span class="sd">         :class:`.AliasedClass` objects, :class:`.Mapper` objects</span>
<span class="sd">         as well as core :class:`.FromClause` elements like subqueries.</span>

<span class="sd">        .. versionchanged:: 0.9</span>
<span class="sd">            This method no longer applies the given FROM object</span>
<span class="sd">            to be the selectable from which matching entities</span>
<span class="sd">            select from; the :meth:`.select_entity_from` method</span>
<span class="sd">            now accomplishes this.  See that method for a description</span>
<span class="sd">            of this behavior.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`~.Query.join`</span>

<span class="sd">            :meth:`.Query.select_entity_from`</span>

<span class="sd">        """</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_select_from</span><span class="p">(</span><span class="n">from_obj</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="nd">@_generative</span><span class="p">(</span><span class="n">_no_clauseelement_condition</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">select_entity_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_obj</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Set the FROM clause of this :class:`.Query` to a</span>
<span class="sd">        core selectable, applying it as a replacement FROM clause</span>
<span class="sd">        for corresponding mapped entities.</span>

<span class="sd">        The :meth:`.Query.select_entity_from` method supplies an alternative</span>
<span class="sd">        approach to the use case of applying an :func:`.aliased` construct</span>
<span class="sd">        explicitly throughout a query.  Instead of referring to the</span>
<span class="sd">        :func:`.aliased` construct explicitly,</span>
<span class="sd">        :meth:`.Query.select_entity_from` automatically *adapts* all</span>
<span class="sd">        occurrences of the entity to the target selectable.</span>

<span class="sd">        Given a case for :func:`.aliased` such as selecting ``User``</span>
<span class="sd">        objects from a SELECT statement::</span>

<span class="sd">            select_stmt = select([User]).where(User.id == 7)</span>
<span class="sd">            user_alias = aliased(User, select_stmt)</span>

<span class="sd">            q = session.query(user_alias).\</span>
<span class="sd">                filter(user_alias.name == 'ed')</span>

<span class="sd">        Above, we apply the ``user_alias`` object explicitly throughout the</span>
<span class="sd">        query.  When it's not feasible for ``user_alias`` to be referenced</span>
<span class="sd">        explicitly in many places, :meth:`.Query.select_entity_from` may be</span>
<span class="sd">        used at the start of the query to adapt the existing ``User`` entity::</span>

<span class="sd">            q = session.query(User).\</span>
<span class="sd">                select_entity_from(select_stmt).\</span>
<span class="sd">                filter(User.name == 'ed')</span>

<span class="sd">        Above, the generated SQL will show that the ``User`` entity is</span>
<span class="sd">        adapted to our statement, even in the case of the WHERE clause:</span>

<span class="sd">        .. sourcecode:: sql</span>

<span class="sd">            SELECT anon_1.id AS anon_1_id, anon_1.name AS anon_1_name</span>
<span class="sd">            FROM (SELECT "user".id AS id, "user".name AS name</span>
<span class="sd">            FROM "user"</span>
<span class="sd">            WHERE "user".id = :id_1) AS anon_1</span>
<span class="sd">            WHERE anon_1.name = :name_1</span>

<span class="sd">        The :meth:`.Query.select_entity_from` method is similar to the</span>
<span class="sd">        :meth:`.Query.select_from` method, in that it sets the FROM clause</span>
<span class="sd">        of the query.  The difference is that it additionally applies</span>
<span class="sd">        adaptation to the other parts of the query that refer to the</span>
<span class="sd">        primary entity.  If above we had used :meth:`.Query.select_from`</span>
<span class="sd">        instead, the SQL generated would have been:</span>

<span class="sd">        .. sourcecode:: sql</span>

<span class="sd">            -- uses plain select_from(), not select_entity_from()</span>
<span class="sd">            SELECT "user".id AS user_id, "user".name AS user_name</span>
<span class="sd">            FROM "user", (SELECT "user".id AS id, "user".name AS name</span>
<span class="sd">            FROM "user"</span>
<span class="sd">            WHERE "user".id = :id_1) AS anon_1</span>
<span class="sd">            WHERE "user".name = :name_1</span>

<span class="sd">        To supply textual SQL to the :meth:`.Query.select_entity_from` method,</span>
<span class="sd">        we can make use of the :func:`.text` construct.  However, the</span>
<span class="sd">        :func:`.text` construct needs to be aligned with the columns of our</span>
<span class="sd">        entity, which is achieved by making use of the</span>
<span class="sd">        :meth:`.TextClause.columns` method::</span>

<span class="sd">            text_stmt = text("select id, name from user").columns(</span>
<span class="sd">                User.id, User.name)</span>
<span class="sd">            q = session.query(User).select_entity_from(text_stmt)</span>

<span class="sd">        :meth:`.Query.select_entity_from` itself accepts an :func:`.aliased`</span>
<span class="sd">        object, so that the special options of :func:`.aliased` such as</span>
<span class="sd">        :paramref:`.aliased.adapt_on_names` may be used within the</span>
<span class="sd">        scope of the :meth:`.Query.select_entity_from` method's adaptation</span>
<span class="sd">        services.  Suppose</span>
<span class="sd">        a view ``user_view`` also returns rows from ``user``.    If</span>
<span class="sd">        we reflect this view into a :class:`.Table`, this view has no</span>
<span class="sd">        relationship to the :class:`.Table` to which we are mapped, however</span>
<span class="sd">        we can use name matching to select from it::</span>

<span class="sd">            user_view = Table('user_view', metadata,</span>
<span class="sd">                              autoload_with=engine)</span>
<span class="sd">            user_view_alias = aliased(</span>
<span class="sd">                User, user_view, adapt_on_names=True)</span>
<span class="sd">            q = session.query(User).\</span>
<span class="sd">                select_entity_from(user_view_alias).\</span>
<span class="sd">                order_by(User.name)</span>

<span class="sd">        .. versionchanged:: 1.1.7 The :meth:`.Query.select_entity_from`</span>
<span class="sd">           method now accepts an :func:`.aliased` object as an alternative</span>
<span class="sd">           to a :class:`.FromClause` object.</span>

<span class="sd">        :param from_obj: a :class:`.FromClause` object that will replace</span>
<span class="sd">         the FROM clause of this :class:`.Query`.  It also may be an instance</span>
<span class="sd">         of :func:`.aliased`.</span>



<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Query.select_from`</span>

<span class="sd">        """</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_select_from</span><span class="p">([</span><span class="n">from_obj</span><span class="p">],</span> <span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">decode_slice</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="mi">0</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="p">[]</span>

            <span class="c1"># perhaps we should execute a count() here so that we</span>
            <span class="c1"># can still use LIMIT/OFFSET ?</span>
            <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">stop</span> <span class="o">&lt;</span> <span class="mi">0</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)[</span><span class="n">item</span><span class="p">]</span>

            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">res</span><span class="p">)[</span><span class="kc">None</span> <span class="p">:</span> <span class="kc">None</span> <span class="p">:</span> <span class="n">item</span><span class="o">.</span><span class="n">step</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">item</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">item</span> <span class="p">:</span> <span class="n">item</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@_generative</span><span class="p">(</span><span class="n">_no_statement_condition</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
        <span class="sd">"""Computes the "slice" of the :class:`.Query` represented by</span>
<span class="sd">        the given indices and returns the resulting :class:`.Query`.</span>

<span class="sd">        The start and stop indices behave like the argument to Python's</span>
<span class="sd">        built-in :func:`range` function. This method provides an</span>
<span class="sd">        alternative to using ``LIMIT``/``OFFSET`` to get a slice of the</span>
<span class="sd">        query.</span>

<span class="sd">        For example, ::</span>

<span class="sd">            session.query(User).order_by(User.id).slice(1, 3)</span>

<span class="sd">        renders as</span>

<span class="sd">        .. sourcecode:: sql</span>

<span class="sd">           SELECT users.id AS users_id,</span>
<span class="sd">                  users.name AS users_name</span>
<span class="sd">           FROM users ORDER BY users.id</span>
<span class="sd">           LIMIT ? OFFSET ?</span>
<span class="sd">           (2, 1)</span>

<span class="sd">        .. seealso::</span>

<span class="sd">           :meth:`.Query.limit`</span>

<span class="sd">           :meth:`.Query.offset`</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">start</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">+=</span> <span class="n">start</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_limit</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>
        <span class="k">elif</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_limit</span> <span class="o">=</span> <span class="n">stop</span>
        <span class="k">elif</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">start</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">+=</span> <span class="n">start</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@_generative</span><span class="p">(</span><span class="n">_no_statement_condition</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
        <span class="sd">"""Apply a ``LIMIT`` to the query and return the newly resulting</span>
<span class="sd">        ``Query``.</span>

<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_limit</span> <span class="o">=</span> <span class="n">limit</span>

    <span class="nd">@_generative</span><span class="p">(</span><span class="n">_no_statement_condition</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="sd">"""Apply an ``OFFSET`` to the query and return the newly resulting</span>
<span class="sd">        ``Query``.</span>

<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="n">offset</span>

    <span class="nd">@_generative</span><span class="p">(</span><span class="n">_no_statement_condition</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">distinct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">expr</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Apply a ``DISTINCT`` to the query and return the newly resulting</span>
<span class="sd">        ``Query``.</span>


<span class="sd">        .. note::</span>

<span class="sd">            The :meth:`.distinct` call includes logic that will automatically</span>
<span class="sd">            add columns from the ORDER BY of the query to the columns</span>
<span class="sd">            clause of the SELECT statement, to satisfy the common need</span>
<span class="sd">            of the database backend that ORDER BY columns be part of the</span>
<span class="sd">            SELECT list when DISTINCT is used.   These columns *are not*</span>
<span class="sd">            added to the list of columns actually fetched by the</span>
<span class="sd">            :class:`.Query`, however, so would not affect results.</span>
<span class="sd">            The columns are passed through when using the</span>
<span class="sd">            :attr:`.Query.statement` accessor, however.</span>

<span class="sd">        :param \*expr: optional column expressions.  When present,</span>
<span class="sd">         the PostgreSQL dialect will render a ``DISTINCT ON (&lt;expressions&gt;)``</span>
<span class="sd">         construct.</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">expr</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_distinct</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_col_list</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_distinct</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_distinct</span> <span class="o">+=</span> <span class="n">expr</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_distinct</span> <span class="o">=</span> <span class="n">expr</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">prefix_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">prefixes</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Apply the prefixes to the query and return the newly resulting</span>
<span class="sd">        ``Query``.</span>

<span class="sd">        :param \*prefixes: optional prefixes, typically strings,</span>
<span class="sd">         not using any commas.   In particular is useful for MySQL keywords</span>
<span class="sd">         and optimizer hints:</span>

<span class="sd">        e.g.::</span>

<span class="sd">            query = sess.query(User.name).\</span>
<span class="sd">                prefix_with('HIGH_PRIORITY').\</span>
<span class="sd">                prefix_with('SQL_SMALL_RESULT', 'ALL').\</span>
<span class="sd">                prefix_with('/*+ BKA(user) */')</span>

<span class="sd">        Would render::</span>

<span class="sd">            SELECT HIGH_PRIORITY SQL_SMALL_RESULT ALL /*+ BKA(user) */</span>
<span class="sd">            users.name AS users_name FROM users</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.HasPrefixes.prefix_with`</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prefixes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_prefixes</span> <span class="o">+=</span> <span class="n">prefixes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_prefixes</span> <span class="o">=</span> <span class="n">prefixes</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">suffix_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">suffixes</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Apply the suffix to the query and return the newly resulting</span>
<span class="sd">        ``Query``.</span>

<span class="sd">        :param \*suffixes: optional suffixes, typically strings,</span>
<span class="sd">         not using any commas.</span>

<span class="sd">        .. versionadded:: 1.0.0</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Query.prefix_with`</span>

<span class="sd">            :meth:`.HasSuffixes.suffix_with`</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_suffixes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_suffixes</span> <span class="o">+=</span> <span class="n">suffixes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_suffixes</span> <span class="o">=</span> <span class="n">suffixes</span>

    <span class="k">def</span> <span class="nf">all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Return the results represented by this :class:`.Query` as a list.</span>

<span class="sd">        This results in an execution of the underlying SQL statement.</span>

<span class="sd">        .. warning::  The :class:`.Query` object, when asked to return either</span>
<span class="sd">           a sequence or iterator that consists of full ORM-mapped entities,</span>
<span class="sd">           will **deduplicate entries based on primary key**.  See the FAQ for</span>
<span class="sd">           more details.</span>

<span class="sd">            .. seealso::</span>

<span class="sd">                :ref:`faq_query_deduplicating`</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@_generative</span><span class="p">(</span><span class="n">_no_clauseelement_condition</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">from_statement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">statement</span><span class="p">):</span>
        <span class="sd">"""Execute the given SELECT statement and return results.</span>

<span class="sd">        This method bypasses all internal statement compilation, and the</span>
<span class="sd">        statement is executed without modification.</span>

<span class="sd">        The statement is typically either a :func:`~.expression.text`</span>
<span class="sd">        or :func:`~.expression.select` construct, and should return the set</span>
<span class="sd">        of columns</span>
<span class="sd">        appropriate to the entity class represented by this :class:`.Query`.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`orm_tutorial_literal_sql` - usage examples in the</span>
<span class="sd">            ORM tutorial</span>

<span class="sd">        """</span>
        <span class="n">statement</span> <span class="o">=</span> <span class="n">expression</span><span class="o">.</span><span class="n">_expression_literal_as_text</span><span class="p">(</span><span class="n">statement</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">statement</span><span class="p">,</span> <span class="p">(</span><span class="n">expression</span><span class="o">.</span><span class="n">TextClause</span><span class="p">,</span> <span class="n">expression</span><span class="o">.</span><span class="n">SelectBase</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                <span class="s2">"from_statement accepts text(), select(), "</span>
                <span class="s2">"and union() objects only."</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_statement</span> <span class="o">=</span> <span class="n">statement</span>

    <span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Return the first result of this ``Query`` or</span>
<span class="sd">        None if the result doesn't contain any row.</span>

<span class="sd">        first() applies a limit of one within the generated SQL, so that</span>
<span class="sd">        only one primary entity row is generated on the server side</span>
<span class="sd">        (note this may consist of multiple result rows if join-loaded</span>
<span class="sd">        collections are present).</span>

<span class="sd">        Calling :meth:`.Query.first` results in an execution of the underlying</span>
<span class="sd">        query.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Query.one`</span>

<span class="sd">            :meth:`.Query.one_or_none`</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statement</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">one_or_none</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Return at most one result or raise an exception.</span>

<span class="sd">        Returns ``None`` if the query selects</span>
<span class="sd">        no rows.  Raises ``sqlalchemy.orm.exc.MultipleResultsFound``</span>
<span class="sd">        if multiple object identities are returned, or if multiple</span>
<span class="sd">        rows are returned for a query that returns only scalar values</span>
<span class="sd">        as opposed to full identity-mapped entities.</span>

<span class="sd">        Calling :meth:`.Query.one_or_none` results in an execution of the</span>
<span class="sd">        underlying query.</span>

<span class="sd">        .. versionadded:: 1.0.9</span>

<span class="sd">            Added :meth:`.Query.one_or_none`</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Query.first`</span>

<span class="sd">            :meth:`.Query.one`</span>

<span class="sd">        """</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">orm_exc</span><span class="o">.</span><span class="n">MultipleResultsFound</span><span class="p">(</span>
                <span class="s2">"Multiple rows were found for one_or_none()"</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">one</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Return exactly one result or raise an exception.</span>

<span class="sd">        Raises ``sqlalchemy.orm.exc.NoResultFound`` if the query selects</span>
<span class="sd">        no rows.  Raises ``sqlalchemy.orm.exc.MultipleResultsFound``</span>
<span class="sd">        if multiple object identities are returned, or if multiple</span>
<span class="sd">        rows are returned for a query that returns only scalar values</span>
<span class="sd">        as opposed to full identity-mapped entities.</span>

<span class="sd">        Calling :meth:`.one` results in an execution of the underlying query.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Query.first`</span>

<span class="sd">            :meth:`.Query.one_or_none`</span>

<span class="sd">        """</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">one_or_none</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">orm_exc</span><span class="o">.</span><span class="n">MultipleResultsFound</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">orm_exc</span><span class="o">.</span><span class="n">MultipleResultsFound</span><span class="p">(</span>
                <span class="s2">"Multiple rows were found for one()"</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">orm_exc</span><span class="o">.</span><span class="n">NoResultFound</span><span class="p">(</span><span class="s2">"No row was found for one()"</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Return the first element of the first result or None</span>
<span class="sd">        if no rows present.  If multiple rows are returned,</span>
<span class="sd">        raises MultipleResultsFound.</span>

<span class="sd">          &gt;&gt;&gt; session.query(Item).scalar()</span>
<span class="sd">          &lt;Item&gt;</span>
<span class="sd">          &gt;&gt;&gt; session.query(Item.id).scalar()</span>
<span class="sd">          1</span>
<span class="sd">          &gt;&gt;&gt; session.query(Item.id).filter(Item.id &lt; 0).scalar()</span>
<span class="sd">          None</span>
<span class="sd">          &gt;&gt;&gt; session.query(Item.id, Item.name).scalar()</span>
<span class="sd">          1</span>
<span class="sd">          &gt;&gt;&gt; session.query(func.count(Parent.id)).scalar()</span>
<span class="sd">          20</span>

<span class="sd">        This results in an execution of the underlying query.</span>

<span class="sd">        """</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">ret</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="n">orm_exc</span><span class="o">.</span><span class="n">NoResultFound</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">context</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compile_context</span><span class="p">()</span>
        <span class="n">context</span><span class="o">.</span><span class="n">statement</span><span class="o">.</span><span class="n">use_labels</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autoflush</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_populate_existing</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_autoflush</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execute_and_instances</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">context</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compile_context</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">bind</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_get_bind_args</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">get_bind</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span>
                <span class="k">else</span> <span class="kc">None</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">UnboundExecutionError</span><span class="p">:</span>
            <span class="n">bind</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">statement</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">bind</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_connection_from_session</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">connection</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execution_options</span><span class="p">:</span>
            <span class="n">conn</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execution_options</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_execution_options</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">conn</span>

    <span class="k">def</span> <span class="nf">_execute_and_instances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">querycontext</span><span class="p">):</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bind_args</span><span class="p">(</span>
            <span class="n">querycontext</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection_from_session</span><span class="p">,</span> <span class="n">close_with_result</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">querycontext</span><span class="o">.</span><span class="n">statement</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">loading</span><span class="o">.</span><span class="n">instances</span><span class="p">(</span><span class="n">querycontext</span><span class="o">.</span><span class="n">query</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">querycontext</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_execute_crud</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">,</span> <span class="n">mapper</span><span class="p">):</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection_from_session</span><span class="p">(</span>
            <span class="n">mapper</span><span class="o">=</span><span class="n">mapper</span><span class="p">,</span> <span class="n">clause</span><span class="o">=</span><span class="n">stmt</span><span class="p">,</span> <span class="n">close_with_result</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_bind_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">querycontext</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">fn</span><span class="p">(</span>
            <span class="n">mapper</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_bind_mapper</span><span class="p">(),</span> <span class="n">clause</span><span class="o">=</span><span class="n">querycontext</span><span class="o">.</span><span class="n">statement</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">column_descriptions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Return metadata about the columns which would be</span>
<span class="sd">        returned by this :class:`.Query`.</span>

<span class="sd">        Format is a list of dictionaries::</span>

<span class="sd">            user_alias = aliased(User, name='user2')</span>
<span class="sd">            q = sess.query(User, User.id, user_alias)</span>

<span class="sd">            # this expression:</span>
<span class="sd">            q.column_descriptions</span>

<span class="sd">            # would return:</span>
<span class="sd">            [</span>
<span class="sd">                {</span>
<span class="sd">                    'name':'User',</span>
<span class="sd">                    'type':User,</span>
<span class="sd">                    'aliased':False,</span>
<span class="sd">                    'expr':User,</span>
<span class="sd">                    'entity': User</span>
<span class="sd">                },</span>
<span class="sd">                {</span>
<span class="sd">                    'name':'id',</span>
<span class="sd">                    'type':Integer(),</span>
<span class="sd">                    'aliased':False,</span>
<span class="sd">                    'expr':User.id,</span>
<span class="sd">                    'entity': User</span>
<span class="sd">                },</span>
<span class="sd">                {</span>
<span class="sd">                    'name':'user2',</span>
<span class="sd">                    'type':User,</span>
<span class="sd">                    'aliased':True,</span>
<span class="sd">                    'expr':user_alias,</span>
<span class="sd">                    'entity': user_alias</span>
<span class="sd">                }</span>
<span class="sd">            ]</span>

<span class="sd">        """</span>

        <span class="k">return</span> <span class="p">[</span>
            <span class="p">{</span>
                <span class="s2">"name"</span><span class="p">:</span> <span class="n">ent</span><span class="o">.</span><span class="n">_label_name</span><span class="p">,</span>
                <span class="s2">"type"</span><span class="p">:</span> <span class="n">ent</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
                <span class="s2">"aliased"</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">insp_ent</span><span class="p">,</span> <span class="s2">"is_aliased_class"</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
                <span class="s2">"expr"</span><span class="p">:</span> <span class="n">ent</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span>
                <span class="s2">"entity"</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">insp_ent</span><span class="p">,</span> <span class="s2">"entity"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ent</span><span class="o">.</span><span class="n">entity_zero</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">insp_ent</span><span class="o">.</span><span class="n">is_clause_element</span>
                <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="n">ent</span><span class="p">,</span> <span class="n">insp_ent</span> <span class="ow">in</span> <span class="p">[</span>
                <span class="p">(</span>
                    <span class="n">_ent</span><span class="p">,</span>
                    <span class="p">(</span>
                        <span class="n">inspect</span><span class="p">(</span><span class="n">_ent</span><span class="o">.</span><span class="n">entity_zero</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">_ent</span><span class="o">.</span><span class="n">entity_zero</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                        <span class="k">else</span> <span class="kc">None</span>
                    <span class="p">),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">_ent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span>
            <span class="p">]</span>
        <span class="p">]</span>

    <span class="k">def</span> <span class="nf">instances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">__context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""Given a ResultProxy cursor as returned by connection.execute(),</span>
<span class="sd">        return an ORM result as an iterator.</span>

<span class="sd">        e.g.::</span>

<span class="sd">            result = engine.execute("select * from users")</span>
<span class="sd">            for u in session.query(User).instances(result):</span>
<span class="sd">                print u</span>
<span class="sd">        """</span>
        <span class="n">context</span> <span class="o">=</span> <span class="n">__context</span>
        <span class="k">if</span> <span class="n">context</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">context</span> <span class="o">=</span> <span class="n">QueryContext</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">loading</span><span class="o">.</span><span class="n">instances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">merge_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterator</span><span class="p">,</span> <span class="n">load</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">"""Merge a result into this :class:`.Query` object's Session.</span>

<span class="sd">        Given an iterator returned by a :class:`.Query` of the same structure</span>
<span class="sd">        as this one, return an identical iterator of results, with all mapped</span>
<span class="sd">        instances merged into the session using :meth:`.Session.merge`. This</span>
<span class="sd">        is an optimized method which will merge all mapped instances,</span>
<span class="sd">        preserving the structure of the result rows and unmapped columns with</span>
<span class="sd">        less method overhead than that of calling :meth:`.Session.merge`</span>
<span class="sd">        explicitly for each value.</span>

<span class="sd">        The structure of the results is determined based on the column list of</span>
<span class="sd">        this :class:`.Query` - if these do not correspond, unchecked errors</span>
<span class="sd">        will occur.</span>

<span class="sd">        The 'load' argument is the same as that of :meth:`.Session.merge`.</span>

<span class="sd">        For an example of how :meth:`~.Query.merge_result` is used, see</span>
<span class="sd">        the source code for the example :ref:`examples_caching`, where</span>
<span class="sd">        :meth:`~.Query.merge_result` is used to efficiently restore state</span>
<span class="sd">        from a cache back into a target :class:`.Session`.</span>

<span class="sd">        """</span>

        <span class="k">return</span> <span class="n">loading</span><span class="o">.</span><span class="n">merge_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterator</span><span class="p">,</span> <span class="n">load</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_select_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">"limit"</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limit</span><span class="p">,</span>
            <span class="s2">"offset"</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">,</span>
            <span class="s2">"distinct"</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distinct</span><span class="p">,</span>
            <span class="s2">"prefixes"</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prefixes</span><span class="p">,</span>
            <span class="s2">"suffixes"</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_suffixes</span><span class="p">,</span>
            <span class="s2">"group_by"</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_by</span> <span class="ow">or</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">"having"</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_having</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_should_nest_selectable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_args</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"limit"</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"offset"</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"distinct"</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">exists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""A convenience method that turns a query into an EXISTS subquery</span>
<span class="sd">        of the form EXISTS (SELECT 1 FROM ... WHERE ...).</span>

<span class="sd">        e.g.::</span>

<span class="sd">            q = session.query(User).filter(User.name == 'fred')</span>
<span class="sd">            session.query(q.exists())</span>

<span class="sd">        Producing SQL similar to::</span>

<span class="sd">            SELECT EXISTS (</span>
<span class="sd">                SELECT 1 FROM users WHERE users.name = :name_1</span>
<span class="sd">            ) AS anon_1</span>

<span class="sd">        The EXISTS construct is usually used in the WHERE clause::</span>

<span class="sd">            session.query(User.id).filter(q.exists()).scalar()</span>

<span class="sd">        Note that some databases such as SQL Server don't allow an</span>
<span class="sd">        EXISTS expression to be present in the columns clause of a</span>
<span class="sd">        SELECT.    To select a simple boolean value based on the exists</span>
<span class="sd">        as a WHERE, use :func:`.literal`::</span>

<span class="sd">            from sqlalchemy import literal</span>

<span class="sd">            session.query(literal(True)).filter(q.exists()).scalar()</span>

<span class="sd">        """</span>

        <span class="c1"># .add_columns() for the case that we are a query().select_from(X),</span>
        <span class="c1"># so that ".statement" can be produced (#2995) but also without</span>
        <span class="c1"># omitting the FROM clause from a query(X) (#2818);</span>
        <span class="c1"># .with_only_columns() after we have a core select() so that</span>
        <span class="c1"># we get just "SELECT 1" without any entities.</span>
        <span class="k">return</span> <span class="n">sql</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">enable_eagerloads</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="o">.</span><span class="n">add_columns</span><span class="p">(</span><span class="n">sql</span><span class="o">.</span><span class="n">literal_column</span><span class="p">(</span><span class="s2">"1"</span><span class="p">))</span>
            <span class="o">.</span><span class="n">with_labels</span><span class="p">()</span>
            <span class="o">.</span><span class="n">statement</span><span class="o">.</span><span class="n">with_only_columns</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Return a count of rows this the SQL formed by this :class:`Query`</span>
<span class="sd">        would return.</span>

<span class="sd">        This generates the SQL for this Query as follows::</span>

<span class="sd">            SELECT count(1) AS count_1 FROM (</span>
<span class="sd">                SELECT &lt;rest of query follows...&gt;</span>
<span class="sd">            ) AS anon_1</span>

<span class="sd">        The above SQL returns a single row, which is the aggregate value</span>
<span class="sd">        of the count function; the :meth:`.Query.count` method then returns</span>
<span class="sd">        that single integer value.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            It is important to note that the value returned by</span>
<span class="sd">            count() is **not the same as the number of ORM objects that this</span>
<span class="sd">            Query would return from a method such as the .all() method**.</span>
<span class="sd">            The :class:`.Query` object, when asked to return full entities,</span>
<span class="sd">            will **deduplicate entries based on primary key**, meaning if the</span>
<span class="sd">            same primary key value would appear in the results more than once,</span>
<span class="sd">            only one object of that primary key would be present.  This does</span>
<span class="sd">            not apply to a query that is against individual columns.</span>

<span class="sd">            .. seealso::</span>

<span class="sd">                :ref:`faq_query_deduplicating`</span>

<span class="sd">                :ref:`orm_tutorial_query_returning`</span>

<span class="sd">        For fine grained control over specific columns to count, to skip the</span>
<span class="sd">        usage of a subquery or otherwise control of the FROM clause, or to use</span>
<span class="sd">        other aggregate functions, use :attr:`~sqlalchemy.sql.expression.func`</span>
<span class="sd">        expressions in conjunction with :meth:`~.Session.query`, i.e.::</span>

<span class="sd">            from sqlalchemy import func</span>

<span class="sd">            # count User records, without</span>
<span class="sd">            # using a subquery.</span>
<span class="sd">            session.query(func.count(User.id))</span>

<span class="sd">            # return count of user "id" grouped</span>
<span class="sd">            # by "name"</span>
<span class="sd">            session.query(func.count(User.id)).\</span>
<span class="sd">                    group_by(User.name)</span>

<span class="sd">            from sqlalchemy import distinct</span>

<span class="sd">            # count distinct "name" values</span>
<span class="sd">            session.query(func.count(distinct(User.name)))</span>

<span class="sd">        """</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">sql</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">sql</span><span class="o">.</span><span class="n">literal_column</span><span class="p">(</span><span class="s2">"*"</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_self</span><span class="p">(</span><span class="n">col</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synchronize_session</span><span class="o">=</span><span class="s2">"evaluate"</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Perform a bulk delete query.</span>

<span class="sd">        Deletes rows matched by this query from the database.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            sess.query(User).filter(User.age == 25).\</span>
<span class="sd">                delete(synchronize_session=False)</span>

<span class="sd">            sess.query(User).filter(User.age == 25).\</span>
<span class="sd">                delete(synchronize_session='evaluate')</span>

<span class="sd">        .. warning:: The :meth:`.Query.delete` method is a "bulk" operation,</span>
<span class="sd">           which bypasses ORM unit-of-work automation in favor of greater</span>
<span class="sd">           performance.  **Please read all caveats and warnings below.**</span>

<span class="sd">        :param synchronize_session: chooses the strategy for the removal of</span>
<span class="sd">            matched objects from the session. Valid values are:</span>

<span class="sd">            ``False`` - don't synchronize the session. This option is the most</span>
<span class="sd">            efficient and is reliable once the session is expired, which</span>
<span class="sd">            typically occurs after a commit(), or explicitly using</span>
<span class="sd">            expire_all(). Before the expiration, objects may still remain in</span>
<span class="sd">            the session which were in fact deleted which can lead to confusing</span>
<span class="sd">            results if they are accessed via get() or already loaded</span>
<span class="sd">            collections.</span>

<span class="sd">            ``'fetch'`` - performs a select query before the delete to find</span>
<span class="sd">            objects that are matched by the delete query and need to be</span>
<span class="sd">            removed from the session. Matched objects are removed from the</span>
<span class="sd">            session.</span>

<span class="sd">            ``'evaluate'`` - Evaluate the query's criteria in Python straight</span>
<span class="sd">            on the objects in the session. If evaluation of the criteria isn't</span>
<span class="sd">            implemented, an error is raised.</span>

<span class="sd">            The expression evaluator currently doesn't account for differing</span>
<span class="sd">            string collations between the database and Python.</span>

<span class="sd">        :return: the count of rows matched as returned by the database's</span>
<span class="sd">          "row count" feature.</span>

<span class="sd">        .. warning:: **Additional Caveats for bulk query deletes**</span>

<span class="sd">            * This method does **not work for joined</span>
<span class="sd">              inheritance mappings**, since the **multiple table</span>
<span class="sd">              deletes are not supported by SQL** as well as that the</span>
<span class="sd">              **join condition of an inheritance mapper is not</span>
<span class="sd">              automatically rendered**.  Care must be taken in any</span>
<span class="sd">              multiple-table delete to first accommodate via some other means</span>
<span class="sd">              how the related table will be deleted, as well as to</span>
<span class="sd">              explicitly include the joining</span>
<span class="sd">              condition between those tables, even in mappings where</span>
<span class="sd">              this is normally automatic. E.g. if a class ``Engineer``</span>
<span class="sd">              subclasses ``Employee``, a DELETE against the ``Employee``</span>
<span class="sd">              table would look like::</span>

<span class="sd">                    session.query(Engineer).\</span>
<span class="sd">                        filter(Engineer.id == Employee.id).\</span>
<span class="sd">                        filter(Employee.name == 'dilbert').\</span>
<span class="sd">                        delete()</span>

<span class="sd">              However the above SQL will not delete from the Engineer table,</span>
<span class="sd">              unless an ON DELETE CASCADE rule is established in the database</span>
<span class="sd">              to handle it.</span>

<span class="sd">              Short story, **do not use this method for joined inheritance</span>
<span class="sd">              mappings unless you have taken the additional steps to make</span>
<span class="sd">              this feasible**.</span>

<span class="sd">            * The polymorphic identity WHERE criteria is **not** included</span>
<span class="sd">              for single- or</span>
<span class="sd">              joined- table updates - this must be added **manually** even</span>
<span class="sd">              for single table inheritance.</span>

<span class="sd">            * The method does **not** offer in-Python cascading of</span>
<span class="sd">              relationships - it is assumed that ON DELETE CASCADE/SET</span>
<span class="sd">              NULL/etc. is configured for any foreign key references</span>
<span class="sd">              which require it, otherwise the database may emit an</span>
<span class="sd">              integrity violation if foreign key references are being</span>
<span class="sd">              enforced.</span>

<span class="sd">              After the DELETE, dependent objects in the</span>
<span class="sd">              :class:`.Session` which were impacted by an ON DELETE</span>
<span class="sd">              may not contain the current state, or may have been</span>
<span class="sd">              deleted. This issue is resolved once the</span>
<span class="sd">              :class:`.Session` is expired, which normally occurs upon</span>
<span class="sd">              :meth:`.Session.commit` or can be forced by using</span>
<span class="sd">              :meth:`.Session.expire_all`.  Accessing an expired</span>
<span class="sd">              object whose row has been deleted will invoke a SELECT</span>
<span class="sd">              to locate the row; when the row is not found, an</span>
<span class="sd">              :class:`~sqlalchemy.orm.exc.ObjectDeletedError` is</span>
<span class="sd">              raised.</span>

<span class="sd">            * The ``'fetch'`` strategy results in an additional</span>
<span class="sd">              SELECT statement emitted and will significantly reduce</span>
<span class="sd">              performance.</span>

<span class="sd">            * The ``'evaluate'`` strategy performs a scan of</span>
<span class="sd">              all matching objects within the :class:`.Session`; if the</span>
<span class="sd">              contents of the :class:`.Session` are expired, such as</span>
<span class="sd">              via a proceeding :meth:`.Session.commit` call, **this will</span>
<span class="sd">              result in SELECT queries emitted for every matching object**.</span>

<span class="sd">            * The :meth:`.MapperEvents.before_delete` and</span>
<span class="sd">              :meth:`.MapperEvents.after_delete`</span>
<span class="sd">              events **are not invoked** from this method.  Instead, the</span>
<span class="sd">              :meth:`.SessionEvents.after_bulk_delete` method is provided to</span>
<span class="sd">              act upon a mass DELETE of entity rows.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Query.update`</span>

<span class="sd">            :ref:`inserts_and_updates` - Core SQL tutorial</span>

<span class="sd">        """</span>

        <span class="n">delete_op</span> <span class="o">=</span> <span class="n">persistence</span><span class="o">.</span><span class="n">BulkDelete</span><span class="o">.</span><span class="n">factory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synchronize_session</span><span class="p">)</span>
        <span class="n">delete_op</span><span class="o">.</span><span class="n">exec_</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">delete_op</span><span class="o">.</span><span class="n">rowcount</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">synchronize_session</span><span class="o">=</span><span class="s2">"evaluate"</span><span class="p">,</span> <span class="n">update_args</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Perform a bulk update query.</span>

<span class="sd">        Updates rows matched by this query in the database.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            sess.query(User).filter(User.age == 25).\</span>
<span class="sd">                update({User.age: User.age - 10}, synchronize_session=False)</span>

<span class="sd">            sess.query(User).filter(User.age == 25).\</span>
<span class="sd">                update({"age": User.age - 10}, synchronize_session='evaluate')</span>


<span class="sd">        .. warning:: The :meth:`.Query.update` method is a "bulk" operation,</span>
<span class="sd">           which bypasses ORM unit-of-work automation in favor of greater</span>
<span class="sd">           performance.  **Please read all caveats and warnings below.**</span>


<span class="sd">        :param values: a dictionary with attributes names, or alternatively</span>
<span class="sd">         mapped attributes or SQL expressions, as keys, and literal</span>
<span class="sd">         values or sql expressions as values.   If :ref:`parameter-ordered</span>
<span class="sd">         mode &lt;updates_order_parameters&gt;` is desired, the values can be</span>
<span class="sd">         passed as a list of 2-tuples;</span>
<span class="sd">         this requires that the</span>
<span class="sd">         :paramref:`~sqlalchemy.sql.expression.update.preserve_parameter_order`</span>
<span class="sd">         flag is passed to the :paramref:`.Query.update.update_args` dictionary</span>
<span class="sd">         as well.</span>

<span class="sd">          .. versionchanged:: 1.0.0 - string names in the values dictionary</span>
<span class="sd">             are now resolved against the mapped entity; previously, these</span>
<span class="sd">             strings were passed as literal column names with no mapper-level</span>
<span class="sd">             translation.</span>

<span class="sd">        :param synchronize_session: chooses the strategy to update the</span>
<span class="sd">         attributes on objects in the session. Valid values are:</span>

<span class="sd">            ``False`` - don't synchronize the session. This option is the most</span>
<span class="sd">            efficient and is reliable once the session is expired, which</span>
<span class="sd">            typically occurs after a commit(), or explicitly using</span>
<span class="sd">            expire_all(). Before the expiration, updated objects may still</span>
<span class="sd">            remain in the session with stale values on their attributes, which</span>
<span class="sd">            can lead to confusing results.</span>

<span class="sd">            ``'fetch'`` - performs a select query before the update to find</span>
<span class="sd">            objects that are matched by the update query. The updated</span>
<span class="sd">            attributes are expired on matched objects.</span>

<span class="sd">            ``'evaluate'`` - Evaluate the Query's criteria in Python straight</span>
<span class="sd">            on the objects in the session. If evaluation of the criteria isn't</span>
<span class="sd">            implemented, an exception is raised.</span>

<span class="sd">            The expression evaluator currently doesn't account for differing</span>
<span class="sd">            string collations between the database and Python.</span>

<span class="sd">        :param update_args: Optional dictionary, if present will be passed</span>
<span class="sd">         to the underlying :func:`.update` construct as the ``**kw`` for</span>
<span class="sd">         the object.  May be used to pass dialect-specific arguments such</span>
<span class="sd">         as ``mysql_limit``, as well as other special arguments such as</span>
<span class="sd">         :paramref:`~sqlalchemy.sql.expression.update.preserve_parameter_order`.</span>

<span class="sd">         .. versionadded:: 1.0.0</span>

<span class="sd">        :return: the count of rows matched as returned by the database's</span>
<span class="sd">         "row count" feature.</span>

<span class="sd">        .. warning:: **Additional Caveats for bulk query updates**</span>

<span class="sd">            * The method does **not** offer in-Python cascading of</span>
<span class="sd">              relationships - it is assumed that ON UPDATE CASCADE is</span>
<span class="sd">              configured for any foreign key references which require</span>
<span class="sd">              it, otherwise the database may emit an integrity</span>
<span class="sd">              violation if foreign key references are being enforced.</span>

<span class="sd">              After the UPDATE, dependent objects in the</span>
<span class="sd">              :class:`.Session` which were impacted by an ON UPDATE</span>
<span class="sd">              CASCADE may not contain the current state; this issue is</span>
<span class="sd">              resolved once the :class:`.Session` is expired, which</span>
<span class="sd">              normally occurs upon :meth:`.Session.commit` or can be</span>
<span class="sd">              forced by using :meth:`.Session.expire_all`.</span>

<span class="sd">            * The ``'fetch'`` strategy results in an additional</span>
<span class="sd">              SELECT statement emitted and will significantly reduce</span>
<span class="sd">              performance.</span>

<span class="sd">            * The ``'evaluate'`` strategy performs a scan of</span>
<span class="sd">              all matching objects within the :class:`.Session`; if the</span>
<span class="sd">              contents of the :class:`.Session` are expired, such as</span>
<span class="sd">              via a proceeding :meth:`.Session.commit` call, **this will</span>
<span class="sd">              result in SELECT queries emitted for every matching object**.</span>

<span class="sd">            * The method supports multiple table updates, as detailed</span>
<span class="sd">              in :ref:`multi_table_updates`, and this behavior does</span>
<span class="sd">              extend to support updates of joined-inheritance and</span>
<span class="sd">              other multiple table mappings.  However, the **join</span>
<span class="sd">              condition of an inheritance mapper is not</span>
<span class="sd">              automatically rendered**. Care must be taken in any</span>
<span class="sd">              multiple-table update to explicitly include the joining</span>
<span class="sd">              condition between those tables, even in mappings where</span>
<span class="sd">              this is normally automatic. E.g. if a class ``Engineer``</span>
<span class="sd">              subclasses ``Employee``, an UPDATE of the ``Engineer``</span>
<span class="sd">              local table using criteria against the ``Employee``</span>
<span class="sd">              local table might look like::</span>

<span class="sd">                    session.query(Engineer).\</span>
<span class="sd">                        filter(Engineer.id == Employee.id).\</span>
<span class="sd">                        filter(Employee.name == 'dilbert').\</span>
<span class="sd">                        update({"engineer_type": "programmer"})</span>

<span class="sd">            * The polymorphic identity WHERE criteria is **not** included</span>
<span class="sd">              for single- or</span>
<span class="sd">              joined- table updates - this must be added **manually**, even</span>
<span class="sd">              for single table inheritance.</span>

<span class="sd">            * The :meth:`.MapperEvents.before_update` and</span>
<span class="sd">              :meth:`.MapperEvents.after_update`</span>
<span class="sd">              events **are not invoked from this method**.  Instead, the</span>
<span class="sd">              :meth:`.SessionEvents.after_bulk_update` method is provided to</span>
<span class="sd">              act upon a mass UPDATE of entity rows.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Query.delete`</span>

<span class="sd">            :ref:`inserts_and_updates` - Core SQL tutorial</span>

<span class="sd">        """</span>

        <span class="n">update_args</span> <span class="o">=</span> <span class="n">update_args</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="n">update_op</span> <span class="o">=</span> <span class="n">persistence</span><span class="o">.</span><span class="n">BulkUpdate</span><span class="o">.</span><span class="n">factory</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">synchronize_session</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">update_args</span>
        <span class="p">)</span>
        <span class="n">update_op</span><span class="o">.</span><span class="n">exec_</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">update_op</span><span class="o">.</span><span class="n">rowcount</span>

    <span class="k">def</span> <span class="nf">_compile_context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">before_compile</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">before_compile</span><span class="p">:</span>
                <span class="n">new_query</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">new_query</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">new_query</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="bp">self</span> <span class="o">=</span> <span class="n">new_query</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">fn</span><span class="o">.</span><span class="n">_bake_ok</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_bake_ok</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">context</span> <span class="o">=</span> <span class="n">QueryContext</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">statement</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">context</span>

        <span class="n">context</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span>

        <span class="n">context</span><span class="o">.</span><span class="n">_for_update_arg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_for_update_arg</span>

        <span class="k">for</span> <span class="n">entity</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">:</span>
            <span class="n">entity</span><span class="o">.</span><span class="n">setup_context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">context</span><span class="o">.</span><span class="n">create_eager_joins</span><span class="p">:</span>
            <span class="n">strategy</span> <span class="o">=</span> <span class="n">rec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">strategy</span><span class="p">(</span><span class="o">*</span><span class="n">rec</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">from_clause</span><span class="p">:</span>
            <span class="c1"># "load from explicit FROMs" mode,</span>
            <span class="c1"># i.e. when select_from() or join() is used</span>
            <span class="n">context</span><span class="o">.</span><span class="n">froms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">from_clause</span><span class="p">)</span>
        <span class="c1"># else "load from discrete FROMs" mode,</span>
        <span class="c1"># i.e. when each _MappedEntity has its own FROM</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enable_single_crit</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_adjust_for_single_inheritance</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">context</span><span class="o">.</span><span class="n">primary_columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_only_load_props</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s2">"No column-based properties specified for "</span>
                    <span class="s2">"refresh operation. Use session.expire() "</span>
                    <span class="s2">"to reload collections and related items."</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s2">"Query contains no columns with which to "</span> <span class="s2">"SELECT from."</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">multi_row_eager_loaders</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_should_nest_selectable</span><span class="p">:</span>
            <span class="n">context</span><span class="o">.</span><span class="n">statement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compound_eager_statement</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">context</span><span class="o">.</span><span class="n">statement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simple_statement</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">context</span>

    <span class="k">def</span> <span class="nf">_compound_eager_statement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="c1"># for eager joins present and LIMIT/OFFSET/DISTINCT,</span>
        <span class="c1"># wrap the query inside a select,</span>
        <span class="c1"># then append eager joins onto that</span>

        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">order_by</span><span class="p">:</span>
            <span class="n">order_by_col_expr</span> <span class="o">=</span> <span class="n">sql_util</span><span class="o">.</span><span class="n">expand_column_list_from_order_by</span><span class="p">(</span>
                <span class="n">context</span><span class="o">.</span><span class="n">primary_columns</span><span class="p">,</span> <span class="n">context</span><span class="o">.</span><span class="n">order_by</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">context</span><span class="o">.</span><span class="n">order_by</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">order_by_col_expr</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">inner</span> <span class="o">=</span> <span class="n">sql</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
            <span class="n">context</span><span class="o">.</span><span class="n">primary_columns</span> <span class="o">+</span> <span class="n">order_by_col_expr</span><span class="p">,</span>
            <span class="n">context</span><span class="o">.</span><span class="n">whereclause</span><span class="p">,</span>
            <span class="n">from_obj</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="n">froms</span><span class="p">,</span>
            <span class="n">use_labels</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span>
            <span class="c1"># TODO: this order_by is only needed if</span>
            <span class="c1"># LIMIT/OFFSET is present in self._select_args,</span>
            <span class="c1"># else the application on the outside is enough</span>
            <span class="n">order_by</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="n">order_by</span><span class="p">,</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_select_args</span>
        <span class="p">)</span>
        <span class="c1"># put FOR UPDATE on the inner query, where MySQL will honor it,</span>
        <span class="c1"># as well as if it has an OF so PostgreSQL can use it.</span>
        <span class="n">inner</span><span class="o">.</span><span class="n">_for_update_arg</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">_for_update_arg</span>

        <span class="k">for</span> <span class="n">hint</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_with_hints</span><span class="p">:</span>
            <span class="n">inner</span> <span class="o">=</span> <span class="n">inner</span><span class="o">.</span><span class="n">with_hint</span><span class="p">(</span><span class="o">*</span><span class="n">hint</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correlate</span><span class="p">:</span>
            <span class="n">inner</span> <span class="o">=</span> <span class="n">inner</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_correlate</span><span class="p">)</span>

        <span class="n">inner</span> <span class="o">=</span> <span class="n">inner</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span>

        <span class="n">equivs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__all_equivs</span><span class="p">()</span>

        <span class="n">context</span><span class="o">.</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">sql_util</span><span class="o">.</span><span class="n">ColumnAdapter</span><span class="p">(</span><span class="n">inner</span><span class="p">,</span> <span class="n">equivs</span><span class="p">)</span>

        <span class="n">statement</span> <span class="o">=</span> <span class="n">sql</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
            <span class="p">[</span><span class="n">inner</span><span class="p">]</span> <span class="o">+</span> <span class="n">context</span><span class="o">.</span><span class="n">secondary_columns</span><span class="p">,</span> <span class="n">use_labels</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="n">labels</span>
        <span class="p">)</span>

        <span class="c1"># Oracle however does not allow FOR UPDATE on the subquery,</span>
        <span class="c1"># and the Oracle dialect ignores it, plus for PostgreSQL, MySQL</span>
        <span class="c1"># we expect that all elements of the row are locked, so also put it</span>
        <span class="c1"># on the outside (except in the case of PG when OF is used)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">context</span><span class="o">.</span><span class="n">_for_update_arg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">context</span><span class="o">.</span><span class="n">_for_update_arg</span><span class="o">.</span><span class="n">of</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="n">statement</span><span class="o">.</span><span class="n">_for_update_arg</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">_for_update_arg</span>

        <span class="n">from_clause</span> <span class="o">=</span> <span class="n">inner</span>
        <span class="k">for</span> <span class="n">eager_join</span> <span class="ow">in</span> <span class="n">context</span><span class="o">.</span><span class="n">eager_joins</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="c1"># EagerLoader places a 'stop_on' attribute on the join,</span>
            <span class="c1"># giving us a marker as to where the "splice point" of</span>
            <span class="c1"># the join should be</span>
            <span class="n">from_clause</span> <span class="o">=</span> <span class="n">sql_util</span><span class="o">.</span><span class="n">splice_joins</span><span class="p">(</span>
                <span class="n">from_clause</span><span class="p">,</span> <span class="n">eager_join</span><span class="p">,</span> <span class="n">eager_join</span><span class="o">.</span><span class="n">stop_on</span>
            <span class="p">)</span>

        <span class="n">statement</span><span class="o">.</span><span class="n">append_from</span><span class="p">(</span><span class="n">from_clause</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">order_by</span><span class="p">:</span>
            <span class="n">statement</span><span class="o">.</span><span class="n">append_order_by</span><span class="p">(</span>
                <span class="o">*</span><span class="n">context</span><span class="o">.</span><span class="n">adapter</span><span class="o">.</span><span class="n">copy_and_process</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">order_by</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">statement</span><span class="o">.</span><span class="n">append_order_by</span><span class="p">(</span><span class="o">*</span><span class="n">context</span><span class="o">.</span><span class="n">eager_order_by</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">statement</span>

    <span class="k">def</span> <span class="nf">_simple_statement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">context</span><span class="o">.</span><span class="n">order_by</span><span class="p">:</span>
            <span class="n">context</span><span class="o">.</span><span class="n">order_by</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distinct</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">context</span><span class="o">.</span><span class="n">order_by</span><span class="p">:</span>
            <span class="n">context</span><span class="o">.</span><span class="n">primary_columns</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">sql_util</span><span class="o">.</span><span class="n">expand_column_list_from_order_by</span>
            <span class="p">)(</span><span class="n">context</span><span class="o">.</span><span class="n">primary_columns</span><span class="p">,</span> <span class="n">context</span><span class="o">.</span><span class="n">order_by</span><span class="p">)</span>
        <span class="n">context</span><span class="o">.</span><span class="n">froms</span> <span class="o">+=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">eager_joins</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="n">statement</span> <span class="o">=</span> <span class="n">sql</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
            <span class="n">context</span><span class="o">.</span><span class="n">primary_columns</span> <span class="o">+</span> <span class="n">context</span><span class="o">.</span><span class="n">secondary_columns</span><span class="p">,</span>
            <span class="n">context</span><span class="o">.</span><span class="n">whereclause</span><span class="p">,</span>
            <span class="n">from_obj</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="n">froms</span><span class="p">,</span>
            <span class="n">use_labels</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span>
            <span class="n">order_by</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="n">order_by</span><span class="p">,</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_select_args</span>
        <span class="p">)</span>
        <span class="n">statement</span><span class="o">.</span><span class="n">_for_update_arg</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">_for_update_arg</span>

        <span class="k">for</span> <span class="n">hint</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_with_hints</span><span class="p">:</span>
            <span class="n">statement</span> <span class="o">=</span> <span class="n">statement</span><span class="o">.</span><span class="n">with_hint</span><span class="p">(</span><span class="o">*</span><span class="n">hint</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correlate</span><span class="p">:</span>
            <span class="n">statement</span> <span class="o">=</span> <span class="n">statement</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_correlate</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">eager_order_by</span><span class="p">:</span>
            <span class="n">statement</span><span class="o">.</span><span class="n">append_order_by</span><span class="p">(</span><span class="o">*</span><span class="n">context</span><span class="o">.</span><span class="n">eager_order_by</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">statement</span>

    <span class="k">def</span> <span class="nf">_adjust_for_single_inheritance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="sd">"""Apply single-table-inheritance filtering.</span>

<span class="sd">        For all distinct single-table-inheritance mappers represented in</span>
<span class="sd">        the columns clause of this query, as well as the "select from entity",</span>
<span class="sd">        add criterion to the WHERE</span>
<span class="sd">        clause of the given QueryContext such that only the appropriate</span>
<span class="sd">        subtypes are selected from the total results.</span>

<span class="sd">        """</span>

        <span class="n">search</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mapper_adapter_map</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_select_from_entity</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_from_entity</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mapper_adapter_map</span>
        <span class="p">):</span>
            <span class="n">insp</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_select_from_entity</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">insp</span><span class="o">.</span><span class="n">is_aliased_class</span><span class="p">:</span>
                <span class="n">adapter</span> <span class="o">=</span> <span class="n">insp</span><span class="o">.</span><span class="n">_adapter</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">adapter</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">search</span> <span class="o">=</span> <span class="n">search</span><span class="o">.</span><span class="n">union</span><span class="p">([(</span><span class="bp">self</span><span class="o">.</span><span class="n">_select_from_entity</span><span class="p">,</span> <span class="n">adapter</span><span class="p">)])</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">ext_info</span><span class="p">,</span> <span class="n">adapter</span><span class="p">)</span> <span class="ow">in</span> <span class="n">search</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ext_info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_entities</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">single_crit</span> <span class="o">=</span> <span class="n">ext_info</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">_single_table_criterion</span>
            <span class="k">if</span> <span class="n">single_crit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">adapter</span><span class="p">:</span>
                    <span class="n">single_crit</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">single_crit</span><span class="p">)</span>

                <span class="n">single_crit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_clause</span><span class="p">(</span><span class="n">single_crit</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                <span class="n">context</span><span class="o">.</span><span class="n">whereclause</span> <span class="o">=</span> <span class="n">sql</span><span class="o">.</span><span class="n">and_</span><span class="p">(</span>
                    <span class="n">sql</span><span class="o">.</span><span class="n">True_</span><span class="o">.</span><span class="n">_ifnone</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">whereclause</span><span class="p">),</span> <span class="n">single_crit</span>
                <span class="p">)</span>


<span class="k">class</span> <span class="nc">LockmodeArg</span><span class="p">(</span><span class="n">ForUpdateArg</span><span class="p">):</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parse_legacy_query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">"read"</span><span class="p">:</span>
            <span class="n">read</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">nowait</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">"update"</span><span class="p">:</span>
            <span class="n">read</span> <span class="o">=</span> <span class="n">nowait</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">"update_nowait"</span><span class="p">:</span>
            <span class="n">nowait</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">read</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                <span class="s2">"Unknown with_lockmode argument: </span><span class="si">%r</span><span class="s2">"</span> <span class="o">%</span> <span class="n">mode</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">LockmodeArg</span><span class="p">(</span><span class="n">read</span><span class="o">=</span><span class="n">read</span><span class="p">,</span> <span class="n">nowait</span><span class="o">=</span><span class="n">nowait</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_QueryEntity</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">"""represent an entity column returned within a Query result."""</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="n">_QueryEntity</span><span class="p">:</span>
            <span class="n">entity</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">entity</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">string_types</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_is_mapped_class</span><span class="p">(</span>
                <span class="n">entity</span>
            <span class="p">):</span>
                <span class="bp">cls</span> <span class="o">=</span> <span class="n">_MapperEntity</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">entity</span><span class="p">,</span> <span class="n">Bundle</span><span class="p">):</span>
                <span class="bp">cls</span> <span class="o">=</span> <span class="n">_BundleEntity</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">cls</span> <span class="o">=</span> <span class="n">_ColumnEntity</span>
        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="n">q</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">q</span>


<span class="k">class</span> <span class="nc">_MapperEntity</span><span class="p">(</span><span class="n">_QueryEntity</span><span class="p">):</span>
    <span class="sd">"""mapper/class/AliasedClass entity"""</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">entity</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">query</span><span class="o">.</span><span class="n">_primary_entity</span><span class="p">:</span>
            <span class="n">query</span><span class="o">.</span><span class="n">_primary_entity</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">query</span><span class="o">.</span><span class="n">_entities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">query</span><span class="o">.</span><span class="n">_has_mapper_entities</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entities</span> <span class="o">=</span> <span class="p">[</span><span class="n">entity</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">=</span> <span class="n">entity</span>

    <span class="n">supports_single_entity</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">use_id_for_hash</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">setup_entity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext_info</span><span class="p">,</span> <span class="n">aliased_adapter</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span> <span class="o">=</span> <span class="n">ext_info</span><span class="o">.</span><span class="n">mapper</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aliased_adapter</span> <span class="o">=</span> <span class="n">aliased_adapter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selectable</span> <span class="o">=</span> <span class="n">ext_info</span><span class="o">.</span><span class="n">selectable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_aliased_class</span> <span class="o">=</span> <span class="n">ext_info</span><span class="o">.</span><span class="n">is_aliased_class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_with_polymorphic</span> <span class="o">=</span> <span class="n">ext_info</span><span class="o">.</span><span class="n">with_polymorphic_mappers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_polymorphic_discriminator</span> <span class="o">=</span> <span class="n">ext_info</span><span class="o">.</span><span class="n">polymorphic_on</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span> <span class="o">=</span> <span class="n">ext_info</span>
        <span class="k">if</span> <span class="n">ext_info</span><span class="o">.</span><span class="n">is_aliased_class</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_label_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_label_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">class_</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span><span class="o">.</span><span class="n">_path_registry</span>

    <span class="k">def</span> <span class="nf">set_with_polymorphic</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">cls_or_mappers</span><span class="p">,</span> <span class="n">selectable</span><span class="p">,</span> <span class="n">polymorphic_on</span>
    <span class="p">):</span>
        <span class="sd">"""Receive an update from a call to query.with_polymorphic().</span>

<span class="sd">        Note the newer style of using a free standing with_polymporphic()</span>
<span class="sd">        construct doesn't make use of this method.</span>


<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_aliased_class</span><span class="p">:</span>
            <span class="c1"># TODO: invalidrequest ?</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">"Can't use with_polymorphic() against "</span> <span class="s2">"an Aliased object"</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">cls_or_mappers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">query</span><span class="o">.</span><span class="n">_reset_polymorphic_adapter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">mappers</span><span class="p">,</span> <span class="n">from_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">_with_polymorphic_args</span><span class="p">(</span>
            <span class="n">cls_or_mappers</span><span class="p">,</span> <span class="n">selectable</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_with_polymorphic</span> <span class="o">=</span> <span class="n">mappers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_polymorphic_discriminator</span> <span class="o">=</span> <span class="n">polymorphic_on</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">selectable</span> <span class="o">=</span> <span class="n">from_obj</span>
        <span class="n">query</span><span class="o">.</span><span class="n">_mapper_loads_polymorphically_with</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="p">,</span>
            <span class="n">sql_util</span><span class="o">.</span><span class="n">ColumnAdapter</span><span class="p">(</span><span class="n">from_obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">_equivalent_columns</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">class_</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">entity_zero_or_selectable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span>

    <span class="k">def</span> <span class="nf">corresponds_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entity</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_entity_corresponds_to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span><span class="p">,</span> <span class="n">entity</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">adapt_to_selectable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">sel</span><span class="p">):</span>
        <span class="n">query</span><span class="o">.</span><span class="n">_entities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_entity_clauses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>

        <span class="n">adapter</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_aliased_class</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">query</span><span class="o">.</span><span class="n">_polymorphic_adapters</span><span class="p">:</span>
                <span class="n">adapter</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_polymorphic_adapters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">adapter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aliased_adapter</span>

        <span class="k">if</span> <span class="n">adapter</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">query</span><span class="o">.</span><span class="n">_from_obj_alias</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">_from_obj_alias</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">adapter</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_from_obj_alias</span>

        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">row_processor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="n">adapter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_entity_clauses</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">adapter</span> <span class="ow">and</span> <span class="n">adapter</span><span class="p">:</span>
            <span class="n">adapter</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">adapter</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">adapter</span><span class="p">:</span>
            <span class="n">adapter</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">adapter</span>

        <span class="c1"># polymorphic mappers which have concrete tables in</span>
        <span class="c1"># their hierarchy usually</span>
        <span class="c1"># require row aliasing unconditionally.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">adapter</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">_requires_row_aliasing</span><span class="p">:</span>
            <span class="n">adapter</span> <span class="o">=</span> <span class="n">sql_util</span><span class="o">.</span><span class="n">ColumnAdapter</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">selectable</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">_equivalent_columns</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">query</span><span class="o">.</span><span class="n">_primary_entity</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">only_load_props</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_only_load_props</span>
            <span class="n">refresh_state</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">refresh_state</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">only_load_props</span> <span class="o">=</span> <span class="n">refresh_state</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">_instance</span> <span class="o">=</span> <span class="n">loading</span><span class="o">.</span><span class="n">_instance_processor</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="p">,</span>
            <span class="n">context</span><span class="p">,</span>
            <span class="n">result</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
            <span class="n">adapter</span><span class="p">,</span>
            <span class="n">only_load_props</span><span class="o">=</span><span class="n">only_load_props</span><span class="p">,</span>
            <span class="n">refresh_state</span><span class="o">=</span><span class="n">refresh_state</span><span class="p">,</span>
            <span class="n">polymorphic_discriminator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_polymorphic_discriminator</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">_instance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label_name</span>

    <span class="k">def</span> <span class="nf">setup_context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="n">adapter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_entity_clauses</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

        <span class="c1"># if self._adapted_selectable is None:</span>
        <span class="n">context</span><span class="o">.</span><span class="n">froms</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selectable</span><span class="p">,)</span>

        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">order_by</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">order_by</span><span class="p">:</span>
            <span class="n">context</span><span class="o">.</span><span class="n">order_by</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">order_by</span>

            <span class="c1"># apply adaptation to the mapper's order_by if needed.</span>
            <span class="k">if</span> <span class="n">adapter</span><span class="p">:</span>
                <span class="n">context</span><span class="o">.</span><span class="n">order_by</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">.</span><span class="n">adapt_list</span><span class="p">(</span>
                    <span class="n">util</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">order_by</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="n">loading</span><span class="o">.</span><span class="n">_setup_entity_query</span><span class="p">(</span>
            <span class="n">context</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="p">,</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
            <span class="n">adapter</span><span class="p">,</span>
            <span class="n">context</span><span class="o">.</span><span class="n">primary_columns</span><span class="p">,</span>
            <span class="n">with_polymorphic</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_with_polymorphic</span><span class="p">,</span>
            <span class="n">only_load_props</span><span class="o">=</span><span class="n">query</span><span class="o">.</span><span class="n">_only_load_props</span><span class="p">,</span>
            <span class="n">polymorphic_discriminator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_polymorphic_discriminator</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="p">)</span>


<span class="nd">@inspection</span><span class="o">.</span><span class="n">_self_inspects</span>
<span class="k">class</span> <span class="nc">Bundle</span><span class="p">(</span><span class="n">InspectionAttr</span><span class="p">):</span>
    <span class="sd">"""A grouping of SQL expressions that are returned by a :class:`.Query`</span>
<span class="sd">    under one namespace.</span>

<span class="sd">    The :class:`.Bundle` essentially allows nesting of the tuple-based</span>
<span class="sd">    results returned by a column-oriented :class:`.Query` object.  It also</span>
<span class="sd">    is extensible via simple subclassing, where the primary capability</span>
<span class="sd">    to override is that of how the set of expressions should be returned,</span>
<span class="sd">    allowing post-processing as well as custom return types, without</span>
<span class="sd">    involving ORM identity-mapped classes.</span>

<span class="sd">    .. versionadded:: 0.9.0</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :ref:`bundles`</span>

<span class="sd">    """</span>

    <span class="n">single_entity</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="sd">"""If True, queries for a single Bundle will be returned as a single</span>
<span class="sd">    entity, rather than an element within a keyed tuple."""</span>

    <span class="n">is_clause_element</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">is_mapper</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">is_aliased_class</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">exprs</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Construct a new :class:`.Bundle`.</span>

<span class="sd">        e.g.::</span>

<span class="sd">            bn = Bundle("mybundle", MyClass.x, MyClass.y)</span>

<span class="sd">            for row in session.query(bn).filter(</span>
<span class="sd">                    bn.c.x == 5).filter(bn.c.y == 4):</span>
<span class="sd">                print(row.mybundle.x, row.mybundle.y)</span>

<span class="sd">        :param name: name of the bundle.</span>
<span class="sd">        :param \*exprs: columns or SQL expressions comprising the bundle.</span>
<span class="sd">        :param single_entity=False: if True, rows for this :class:`.Bundle`</span>
<span class="sd">         can be returned as a "single entity" outside of any enclosing tuple</span>
<span class="sd">         in the same manner as a mapped entity.</span>

<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="n">exprs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">ColumnCollection</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s2">"key"</span><span class="p">,</span> <span class="n">col</span><span class="o">.</span><span class="n">_label</span><span class="p">),</span> <span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">exprs</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">single_entity</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"single_entity"</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_entity</span><span class="p">)</span>

    <span class="n">columns</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">"""A namespace of SQL expressions referred to by this :class:`.Bundle`.</span>

<span class="sd">        e.g.::</span>

<span class="sd">            bn = Bundle("mybundle", MyClass.x, MyClass.y)</span>

<span class="sd">            q = sess.query(bn).filter(bn.c.x == 5)</span>

<span class="sd">        Nesting of bundles is also supported::</span>

<span class="sd">            b1 = Bundle("b1",</span>
<span class="sd">                    Bundle('b2', MyClass.a, MyClass.b),</span>
<span class="sd">                    Bundle('b3', MyClass.x, MyClass.y)</span>
<span class="sd">                )</span>

<span class="sd">            q = sess.query(b1).filter(</span>
<span class="sd">                b1.c.b2.c.a == 5).filter(b1.c.b3.c.y == 9)</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :attr:`.Bundle.c`</span>

<span class="sd">    """</span>

    <span class="n">c</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">"""An alias for :attr:`.Bundle.columns`."""</span>

    <span class="k">def</span> <span class="nf">_clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">cloned</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="n">cloned</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cloned</span>

    <span class="k">def</span> <span class="nf">__clause_element__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">expression</span><span class="o">.</span><span class="n">ClauseList</span><span class="p">(</span><span class="n">group</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">clauses</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__clause_element__</span><span class="p">()</span><span class="o">.</span><span class="n">clauses</span>

    <span class="k">def</span> <span class="nf">label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">"""Provide a copy of this :class:`.Bundle` passing a new label."""</span>

        <span class="n">cloned</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">()</span>
        <span class="n">cloned</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">return</span> <span class="n">cloned</span>

    <span class="k">def</span> <span class="nf">create_row_processor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">procs</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
        <span class="sd">"""Produce the "row processing" function for this :class:`.Bundle`.</span>

<span class="sd">        May be overridden by subclasses.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`bundles` - includes an example of subclassing.</span>

<span class="sd">        """</span>
        <span class="n">keyed_tuple</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">lightweight_named_tuple</span><span class="p">(</span><span class="s2">"result"</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">proc</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">keyed_tuple</span><span class="p">([</span><span class="n">proc</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">proc</span> <span class="ow">in</span> <span class="n">procs</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">proc</span>


<span class="k">class</span> <span class="nc">_BundleEntity</span><span class="p">(</span><span class="n">_QueryEntity</span><span class="p">):</span>
    <span class="n">use_id_for_hash</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">bundle</span><span class="p">,</span> <span class="n">setup_entities</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">query</span><span class="o">.</span><span class="n">_entities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bundle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">=</span> <span class="n">bundle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">bundle</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_label_name</span> <span class="o">=</span> <span class="n">bundle</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">setup_entities</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">bundle</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Bundle</span><span class="p">):</span>
                    <span class="n">_BundleEntity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_ColumnEntity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">supports_single_entity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bundle</span><span class="o">.</span><span class="n">single_entity</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mapper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ezero</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span>
        <span class="k">if</span> <span class="n">ezero</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ezero</span><span class="o">.</span><span class="n">mapper</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">entities</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">entities</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">:</span>
            <span class="n">entities</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ent</span><span class="o">.</span><span class="n">entities</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">entities</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">entity_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">:</span>
            <span class="n">ezero</span> <span class="o">=</span> <span class="n">ent</span><span class="o">.</span><span class="n">entity_zero</span>
            <span class="k">if</span> <span class="n">ezero</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ezero</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">corresponds_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entity</span><span class="p">):</span>
        <span class="c1"># TODO: we might be able to implement this but for now</span>
        <span class="c1"># we are working around it</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">entity_zero_or_selectable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">:</span>
            <span class="n">ezero</span> <span class="o">=</span> <span class="n">ent</span><span class="o">.</span><span class="n">entity_zero_or_selectable</span>
            <span class="k">if</span> <span class="n">ezero</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ezero</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">adapt_to_selectable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">sel</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">_BundleEntity</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bundle</span><span class="p">,</span> <span class="n">setup_entities</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># c._label_name = self._label_name</span>
        <span class="c1"># c.entity_zero = self.entity_zero</span>
        <span class="c1"># c.entities = self.entities</span>

        <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">:</span>
            <span class="n">ent</span><span class="o">.</span><span class="n">adapt_to_selectable</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sel</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setup_entity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext_info</span><span class="p">,</span> <span class="n">aliased_adapter</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">:</span>
            <span class="n">ent</span><span class="o">.</span><span class="n">setup_entity</span><span class="p">(</span><span class="n">ext_info</span><span class="p">,</span> <span class="n">aliased_adapter</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setup_context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">:</span>
            <span class="n">ent</span><span class="o">.</span><span class="n">setup_context</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">row_processor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="n">procs</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="o">*</span><span class="p">[</span>
                <span class="n">ent</span><span class="o">.</span><span class="n">row_processor</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="n">proc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bundle</span><span class="o">.</span><span class="n">create_row_processor</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">procs</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">proc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label_name</span>


<span class="k">class</span> <span class="nc">_ColumnEntity</span><span class="p">(</span><span class="n">_QueryEntity</span><span class="p">):</span>
    <span class="sd">"""Column/expression based entity."""</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">=</span> <span class="n">column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span> <span class="o">=</span> <span class="n">namespace</span>
        <span class="n">search_entities</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">check_column</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
            <span class="n">util</span><span class="o">.</span><span class="n">warn_deprecated</span><span class="p">(</span>
                <span class="s2">"Plain string expression passed to Query() should be "</span>
                <span class="s2">"explicitly declared using literal_column(); "</span>
                <span class="s2">"automatic coercion of this value will be removed in "</span>
                <span class="s2">"SQLAlchemy 1.4"</span>
            <span class="p">)</span>
            <span class="n">column</span> <span class="o">=</span> <span class="n">sql</span><span class="o">.</span><span class="n">literal_column</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_label_name</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">name</span>
            <span class="n">search_entities</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">check_column</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">_entity</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">column</span><span class="p">,</span> <span class="p">(</span><span class="n">attributes</span><span class="o">.</span><span class="n">QueryableAttribute</span><span class="p">,</span> <span class="n">interfaces</span><span class="o">.</span><span class="n">PropComparator</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">_entity</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="s2">"_parententity"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_entity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">search_entities</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_label_name</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">key</span>
            <span class="n">column</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">_query_clause_element</span><span class="p">()</span>
            <span class="n">check_column</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">Bundle</span><span class="p">):</span>
                <span class="n">_BundleEntity</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">column</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">sql</span><span class="o">.</span><span class="n">ColumnElement</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="s2">"_select_iterable"</span><span class="p">):</span>
                <span class="c1"># break out an object like Table into</span>
                <span class="c1"># individual columns</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">column</span><span class="o">.</span><span class="n">_select_iterable</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="n">column</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="n">_ColumnEntity</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="n">column</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span>

            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">"SQL expression, column, or mapped entity "</span>
                <span class="s2">"expected - got '</span><span class="si">%r</span><span class="s2">'"</span> <span class="o">%</span> <span class="p">(</span><span class="n">column</span><span class="p">,)</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">check_column</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_label_name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="s2">"key"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">search_entities</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type_</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_id_for_hash</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">type_</span><span class="o">.</span><span class="n">hashable</span>

        <span class="c1"># If the Column is unnamed, give it a</span>
        <span class="c1"># label() so that mutable column expressions</span>
        <span class="c1"># can be located in the result even</span>
        <span class="c1"># if the expression's identity has been changed</span>
        <span class="c1"># due to adaption.</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">column</span><span class="o">.</span><span class="n">_label</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="s2">"is_literal"</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">column</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_label_name</span><span class="p">)</span>

        <span class="n">query</span><span class="o">.</span><span class="n">_entities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">=</span> <span class="n">column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">froms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># look for ORM entities represented within the</span>
        <span class="c1"># given expression.  Try to count only entities</span>
        <span class="c1"># for columns whose FROM object is in the actual list</span>
        <span class="c1"># of FROMs for the overall expression - this helps</span>
        <span class="c1"># subqueries which were built from ORM constructs from</span>
        <span class="c1"># leaking out their entities into the main select construct</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actual_froms</span> <span class="o">=</span> <span class="n">actual_froms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">_from_objects</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">search_entities</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span> <span class="o">=</span> <span class="n">_entity</span>
            <span class="k">if</span> <span class="n">_entity</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">entities</span> <span class="o">=</span> <span class="p">[</span><span class="n">_entity</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span> <span class="o">=</span> <span class="n">_entity</span><span class="o">.</span><span class="n">mapper</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">entities</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_from_entities</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entities</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">all_elements</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">elem</span>
                <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">sql_util</span><span class="o">.</span><span class="n">surface_column_elements</span><span class="p">(</span>
                    <span class="n">column</span><span class="p">,</span> <span class="n">include_scalar_selects</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="s2">"parententity"</span> <span class="ow">in</span> <span class="n">elem</span><span class="o">.</span><span class="n">_annotations</span>
            <span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">entities</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">unique_list</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">elem</span><span class="o">.</span><span class="n">_annotations</span><span class="p">[</span><span class="s2">"parententity"</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">all_elements</span>
                    <span class="k">if</span> <span class="s2">"parententity"</span> <span class="ow">in</span> <span class="n">elem</span><span class="o">.</span><span class="n">_annotations</span>
                <span class="p">]</span>
            <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_from_entities</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">elem</span><span class="o">.</span><span class="n">_annotations</span><span class="p">[</span><span class="s2">"parententity"</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">all_elements</span>
                    <span class="k">if</span> <span class="s2">"parententity"</span> <span class="ow">in</span> <span class="n">elem</span><span class="o">.</span><span class="n">_annotations</span>
                    <span class="ow">and</span> <span class="n">actual_froms</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">elem</span><span class="o">.</span><span class="n">_from_objects</span><span class="p">)</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">entities</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entities</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span><span class="o">.</span><span class="n">mapper</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">supports_single_entity</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">entity_zero_or_selectable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">actual_froms</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">actual_froms</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">adapt_to_selectable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">sel</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">_ColumnEntity</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">sel</span><span class="o">.</span><span class="n">corresponding_column</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">))</span>
        <span class="n">c</span><span class="o">.</span><span class="n">_label_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label_name</span>
        <span class="n">c</span><span class="o">.</span><span class="n">entity_zero</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span>
        <span class="n">c</span><span class="o">.</span><span class="n">entities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entities</span>

    <span class="k">def</span> <span class="nf">setup_entity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext_info</span><span class="p">,</span> <span class="n">aliased_adapter</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">"selectable"</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">selectable</span> <span class="o">=</span> <span class="n">ext_info</span><span class="o">.</span><span class="n">selectable</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">actual_froms</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">ext_info</span><span class="o">.</span><span class="n">selectable</span><span class="o">.</span><span class="n">_from_objects</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">froms</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ext_info</span><span class="o">.</span><span class="n">selectable</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">corresponds_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entity</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">_is_aliased_class</span><span class="p">(</span><span class="n">entity</span><span class="p">):</span>
            <span class="c1"># TODO: polymorphic subclasses ?</span>
            <span class="k">return</span> <span class="n">entity</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="ow">not</span> <span class="n">_is_aliased_class</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span>
            <span class="p">)</span> <span class="ow">and</span> <span class="n">entity</span><span class="o">.</span><span class="n">common_parent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">row_processor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="s2">"fetch_column"</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span> <span class="ow">in</span> <span class="n">context</span><span class="o">.</span><span class="n">attributes</span><span class="p">:</span>
            <span class="n">column</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">attributes</span><span class="p">[(</span><span class="s2">"fetch_column"</span><span class="p">,</span> <span class="bp">self</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">column</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_adapt_clause</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">column</span><span class="o">.</span><span class="n">_annotations</span><span class="p">:</span>
            <span class="c1"># annotated columns perform more slowly in compiler and</span>
            <span class="c1"># result due to the __eq__() method, so use deannotated</span>
            <span class="n">column</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">_deannotate</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">adapter</span><span class="p">:</span>
            <span class="n">column</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">adapter</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">column</span><span class="p">]</span>

        <span class="n">getter</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_getter</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">getter</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label_name</span>

    <span class="k">def</span> <span class="nf">setup_context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="n">column</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_adapt_clause</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">column</span><span class="o">.</span><span class="n">_annotations</span><span class="p">:</span>
            <span class="c1"># annotated columns perform more slowly in compiler and</span>
            <span class="c1"># result due to the __eq__() method, so use deannotated</span>
            <span class="n">column</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">_deannotate</span><span class="p">()</span>

        <span class="n">context</span><span class="o">.</span><span class="n">froms</span> <span class="o">+=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">froms</span><span class="p">)</span>
        <span class="n">context</span><span class="o">.</span><span class="n">primary_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>

        <span class="n">context</span><span class="o">.</span><span class="n">attributes</span><span class="p">[(</span><span class="s2">"fetch_column"</span><span class="p">,</span> <span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">column</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">QueryContext</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">"multi_row_eager_loaders"</span><span class="p">,</span>
        <span class="s2">"adapter"</span><span class="p">,</span>
        <span class="s2">"froms"</span><span class="p">,</span>
        <span class="s2">"for_update"</span><span class="p">,</span>
        <span class="s2">"query"</span><span class="p">,</span>
        <span class="s2">"session"</span><span class="p">,</span>
        <span class="s2">"autoflush"</span><span class="p">,</span>
        <span class="s2">"populate_existing"</span><span class="p">,</span>
        <span class="s2">"invoke_all_eagers"</span><span class="p">,</span>
        <span class="s2">"version_check"</span><span class="p">,</span>
        <span class="s2">"refresh_state"</span><span class="p">,</span>
        <span class="s2">"primary_columns"</span><span class="p">,</span>
        <span class="s2">"secondary_columns"</span><span class="p">,</span>
        <span class="s2">"eager_order_by"</span><span class="p">,</span>
        <span class="s2">"eager_joins"</span><span class="p">,</span>
        <span class="s2">"create_eager_joins"</span><span class="p">,</span>
        <span class="s2">"propagate_options"</span><span class="p">,</span>
        <span class="s2">"attributes"</span><span class="p">,</span>
        <span class="s2">"statement"</span><span class="p">,</span>
        <span class="s2">"from_clause"</span><span class="p">,</span>
        <span class="s2">"whereclause"</span><span class="p">,</span>
        <span class="s2">"order_by"</span><span class="p">,</span>
        <span class="s2">"labels"</span><span class="p">,</span>
        <span class="s2">"_for_update_arg"</span><span class="p">,</span>
        <span class="s2">"runid"</span><span class="p">,</span>
        <span class="s2">"partials"</span><span class="p">,</span>
        <span class="s2">"post_load_paths"</span><span class="p">,</span>
        <span class="s2">"identity_token"</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">query</span><span class="o">.</span><span class="n">_statement</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">_statement</span><span class="p">,</span> <span class="n">expression</span><span class="o">.</span><span class="n">SelectBase</span><span class="p">)</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">query</span><span class="o">.</span><span class="n">_statement</span><span class="o">.</span><span class="n">_textual</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">query</span><span class="o">.</span><span class="n">_statement</span><span class="o">.</span><span class="n">use_labels</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">statement</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_statement</span><span class="o">.</span><span class="n">apply_labels</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">statement</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_statement</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">statement</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">from_clause</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_from_obj</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">whereclause</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_criterion</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order_by</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_order_by</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">multi_row_eager_loaders</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adapter</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">froms</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">for_update</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">query</span> <span class="o">=</span> <span class="n">query</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">session</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoflush</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_autoflush</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">populate_existing</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_populate_existing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invoke_all_eagers</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_invoke_all_eagers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">version_check</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_version_check</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refresh_state</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_refresh_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">primary_columns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">secondary_columns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eager_order_by</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eager_joins</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_eager_joins</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">propagate_options</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
            <span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">query</span><span class="o">.</span><span class="n">_with_options</span> <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">propagate_to_loaders</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_attributes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">refresh_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">identity_token</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_refresh_identity_token</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">identity_token</span> <span class="o">=</span> <span class="kc">None</span>


<span class="k">class</span> <span class="nc">AliasOption</span><span class="p">(</span><span class="n">interfaces</span><span class="o">.</span><span class="n">MapperOption</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alias</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Return a :class:`.MapperOption` that will indicate to the :class:`.Query`</span>
<span class="sd">        that the main table has been aliased.</span>

<span class="sd">        This is a seldom-used option to suit the</span>
<span class="sd">        very rare case that :func:`.contains_eager`</span>
<span class="sd">        is being used in conjunction with a user-defined SELECT</span>
<span class="sd">        statement that aliases the parent table.  E.g.::</span>

<span class="sd">            # define an aliased UNION called 'ulist'</span>
<span class="sd">            ulist = users.select(users.c.user_id==7).\</span>
<span class="sd">                            union(users.select(users.c.user_id&gt;7)).\</span>
<span class="sd">                            alias('ulist')</span>

<span class="sd">            # add on an eager load of "addresses"</span>
<span class="sd">            statement = ulist.outerjoin(addresses).\</span>
<span class="sd">                            select().apply_labels()</span>

<span class="sd">            # create query, indicating "ulist" will be an</span>
<span class="sd">            # alias for the main table, "addresses"</span>
<span class="sd">            # property should be eager loaded</span>
<span class="sd">            query = session.query(User).options(</span>
<span class="sd">                                    contains_alias(ulist),</span>
<span class="sd">                                    contains_eager(User.addresses))</span>

<span class="sd">            # then get results via the statement</span>
<span class="sd">            results = query.from_statement(statement).all()</span>

<span class="sd">        :param alias: is the string name of an alias, or a</span>
<span class="sd">         :class:`~.sql.expression.Alias` object representing</span>
<span class="sd">         the alias.</span>

<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alias</span> <span class="o">=</span> <span class="n">alias</span>

    <span class="k">def</span> <span class="nf">process_query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alias</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
            <span class="n">alias</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_mapper_zero</span><span class="p">()</span><span class="o">.</span><span class="n">persist_selectable</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alias</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias</span>
        <span class="n">query</span><span class="o">.</span><span class="n">_from_obj_alias</span> <span class="o">=</span> <span class="n">sql_util</span><span class="o">.</span><span class="n">ColumnAdapter</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span>
</pre></div>

          </article>
        </div>
      </div>
    </main>
  </div>
  <footer class="md-footer">
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
          
          
        </a>
        
      </nav>
    </div>
    <div class="md-footer-meta md-typeset">
      <div class="md-footer-meta__inner md-grid">
        <div class="md-footer-copyright">
          <div class="md-footer-copyright__highlight">
              &#169; Copyright 2018, Brian Cappello.
              
          </div>
            Created using
            <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.0.
             and
            <a href="https://github.com/bashtage/sphinx-material/">Material for
              Sphinx</a>
        </div>
      </div>
    </div>
  </footer>
  <script src="../../../_static/javascripts/application.js"></script>
  <script>app.initialize({version: "1.0.4", url: {base: ".."}})</script>
  </body>
</html>